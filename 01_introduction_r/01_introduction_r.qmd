---
format:
  revealjs:
    theme: custom.scss
    fontsize: 1.8em
editor: visual
title-slide-attributes: 
  data-background-image: img/title.png
  data-background-opacity: 50%
---

![](img/title.png){fig-align="center"}

# Introduction

## Qu'est-ce que R ?

<br>

R est un **langage de programmation** et un **logiciel** utilis√© pour r√©aliser des calculs statistiques et des graphiques.

R a √©t√© con√ßu en 1992 par **Ross Ihaka** et **Robert Gentleman** comme impl√©mentation open source du langage de programmation S et publi√© en 1995.

<br>

Depuis, les utilisations de R se sont largement diversifi√©es :

-   analyses statistiques et workflows de data science

-   visualisations graphiques avanc√©es

-   rapports automatis√©s

-   applications web

-   diaporamas, livres, et pages web

## Pourquoi (pas) R ?

<br>

#### **Avantages :**

-   libre, open source, et plateforme ind√©pendant

-   large vari√©t√© d'extensions proposant des fonctionnalit√©s suppl√©mentaires

-   compatible avec d'autres langages de programmation

-   puissant pour l'analyse et la visualisation de donn√©es

-   tr√®s large communaut√© en ligne

-   souvent exp√©riment√© comme √©tant *simple √† coder* (pour un novice)

## Pourquoi (pas) R ?

<br>

#### **Inconv√©nients :**

-   performance : √©volutivit√©, m√©moire et vitesse

-   courbe d'apprentissage importante

-   potentiels probl√®mes de s√©curit√© (applications web)

-   souvent exp√©riment√© comme √©tant *√©trange √† coder* (pour un expert)

# R versus RStudio

## 

![Inspir√© de [Modern Drive](https://moderndive.com/index.html)](img/r_vs_rstudio.png){fig-align="center" width="80%"}

<br>

-   **RStudio** est un environnement de d√©veloppement int√©gr√© (IDE) open source

-   IDE pour R le plus populaire depuis plusieurs ann√©es

-   de nombreuses fonctionnalit√©s et extensions pour faciliter les workflows (suivi de version, sommaire, add-ins, ...)

-   projets R et RMarkdown/Quarto

## Mise en pratique : installer R et RStudio

<br>

-   T√©l√©charger et installer R depuis

    [cloud.r-project.org](https://cloud.r-project.org)

<br>

-   T√©l√©charger et installer RStudio Desktop depuis

    [posit.co/download/rstudio-desktop](https:://posit.co/download/rstudio-desktop)

## 

![](img/r_windows.png){fig-align="center"}

## 

![](img/r_studio_01.png){fig-align="center"}

## 

![](img/r_studio_02.png){fig-align="center"}

## Console et script

<br>

-   La **console** vous permet de taper du code et de l'ex√©cuter.

    -   le code tap√© dans la console sera perdu quand vous quitterez R ...

    -   ... ce qui est probl√©matique pour sauvegarder et partager votre code !

<br>

-   Un **script**, √† la mani√®re d'un document texte, vous permet de sauvegarder votre code et de le partager.

<br>

-   Dans la console, le code est tap√© √† la suite de l'**invite de commande `>`**.

-   La console affiche la **sortie** (le r√©sultat) du code √† la ligne suivante (d√©bute par `[1]`).

-   Le code ex√©cut√© √† partir d'un script s'affiche dans la console.

## Mise en pratique : console et script

<br>

-   Ouvrez **R**, tapez les commandes suivantes et appuyez sur `Entr√©e` pour les ex√©cuter :

    -   `"Ceci est du texte"`

    -   `2 + 2`

<br>

-   Ouvrez **RStudio**

    -   Ouvrez un script (`File > New File > RScript`)

    -   Ajoutez les deux commandes ci-dessus et ex√©cutez-les en pla√ßant le curseur √† la fin de la premi√®re ligne et en cliquant sur `Run` (ou en utilisant le raccourci clavier `Ctrl + Entr√©e`)

    -   Sauvegardez le script (`Ctrl + S`)

## Les commentaires

<br>

Les commentaires servent √† :

-   **inactiver** du code qu'on ne souhaite plus ex√©cuter

-   ajouter des commentaires pour **expliquer** notre raisonnement

Dans R, les commentaires sont cod√©s par un hash `#`.

Tout ce qui suit sur la m√™me ligne ne sera pas trait√© comme du code.

<br>

Par convention, nous utilisons :

-   `#` pour commenter du code

-   `##` pour ajouter des commentaires :

```{r, echo=TRUE, eval=TRUE}
# "Ceci est du texte"  ## Cette ligne n'est plus utile
```

## Les commentaires

<br>

Prenez d√®s maintenant l'habitude de commenter vos scripts.

Cela les rendra plus **compr√©hensibles** - pour vous et pour vos coll√®gues !

Les commentaires peuvent vous servir √† cr√©er un en-t√™te (quoi ? qui ? quand ?)

<br>

Les commentaires servent √©galement √† structurer un script et √† afficher une table des mati√®res, en ajoutant quatre tirets `-` apr√®s un titre :

![](img/toc_01.png){fig-align="center"}

## Mise en pratique : commenter un script

<br>

-   Ouvrez un nouveau script et renseignez les informations essentielles (quoi ? qui ? quand ?)

<br>

-   Ajoutez deux titres de sections

## Mise en pratique : commenter un script

<br>

-   Ouvrez un nouveau script et renseignez les informations essentielles (quoi ? qui ? quand ?)

<br>

-   Ajoutez deux titres de sections

<br>

```{r, echo=TRUE, eval=TRUE}
## Ateliers codons
## Premiers pas avec R
## NOM Prenom
## Date

## Section 1 ----
## Section 2 ----
```

## Mise en pratique : param√®tres de RStudio

<br>

-   Cliquez sur `Help > Cheatsheets > RStudio IDE Cheat Sheet` et parcourez le document qui s'ouvre.

-   Cliquez sur `View > Panes > Pane Layout` et arrangez les panneaux selon votre pr√©f√©rence.

-   Cliquez sur `Tools > Global Options` et parcourez les diff√©rents √©l√©ments.

## 

![](img/r_studio_04.png){fig-align="center"}

## 

![](img/r_studio_05.png){fig-align="center"}

## 

![](img/r_studio_06.png){fig-align="center"}

## 

![](img/r_studio_07.png){fig-align="center"}

# Organiser son travail

## Les projets R

<br>

Les projets R (ou projets RStudio) vous fournissent un **workflow robuste** qui vous servira par la suite :

-   ils reposent sur l'id√©e que tous les fichiers associ√©s √† votre projet devraient √™tre stock√©s **dans le m√™me dossier**

    -   aide √† (re)trouver les fichiers

    -   augmente la reproductibilit√©

    -   facilite la collaboration

-   le **r√©pertoire de travail** est d√©fini dans le dossier o√π se trouve le fichier `.Rproj`

    -   le r√©pertoire de travail est clairement d√©fini

    -   ind√©pendant des param√®tres du syst√®me d'op√©ration et de l'arborescence des dossiers (propre √† chaque utilisateur)

    -   limite les changements de r√©pertoire lors de collaborations

## Mise en pratique : cr√©er un projet

<br>

Pour cr√©er un projet R : `File > New Project ‚Ä¶`

![](img/r_projects_01.png){fig-align="center"}

## Mise en pratique : cr√©er un projet

<br>

::: {layout-ncol="2"}
![](img/r_projects_02.png)

![](img/r_projects_03.png)
:::

## Arborescence

<br>

Une **bonne organisation** de vos fichiers avec une **bonne structure** de vos dossiers vous √©vitera de perdre du temps √† chercher des fichiers.

<br>

La structure propos√©e ci-dessous est applicable √† une bonne partie des projets :

<br>

üìÇ**Donn√©es brutes** : donn√©es que vous r√©cup√©rez au d√©but du projet

üìÇ**Donn√©es modifi√©es** : donn√©es g√©n√©r√©es en cours d'analyse

üìÇ**Scripts** : code utilis√© pour l'analyse, pour g√©n√©rer les figures, r√©diger des rapports

üìÇ**R√©sultats** : tableaux ou fichiers de r√©sultats interm√©diaires / finaux

üìÇ**Figures** : figures g√©n√©r√©es en cours d'analyse et pour pr√©senter les r√©sultats

üìÇ**Documents** : rapports, pr√©sentations, articles, documentation

## Mise en pratique : cr√©er une arborescence

<br>

-   Cliquez sur `New Folder` pour ajouter des dossiers dans votre r√©pertoire de travail

![](img/rstudio_folders_01.png){fig-align="center"}

<br>

-   Cr√©ez l'arborescence qui vous semble la mieux adapt√©e (pensez √† utiliser des nombres quand vous nommez vos dossiers pour conserver l'ordre)

## Mise en pratique : cr√©er une arborescence

<br>

-   Cliquez sur `New Folder` pour ajouter des dossiers dans votre r√©pertoire de travail

<br>

-   Cr√©ez l'arborescence qui vous semble la mieux adapt√©e (pensez √† utiliser des nombres quand vous nommez vos dossiers pour conserver l'ordre)

![](img/rstudio_folders_02.png){fig-align="center"}

# Valeurs

## Valeurs

<br>

Tapez et ex√©cutez les commandes suivantes :

<br>

`1`

`"Ceci est du texte"`

`"2023-09-11 14:00:00"`

`x`

`"x"`

`pi`

## Valeurs

<br>

```{r, echo=TRUE, eval=TRUE, error=TRUE}
1
"Ceci est du texte"
"2023-09-11 14:00:00"
x
"x"
pi
```

<br>

üí°R est un **langage orient√© objet** : tous les √©lements que vous manipulez dans R (donn√©es, fonctions, ...) sont stock√©s dans des objets.

# Fonctions

## Mise en pratique : op√©rations arithm√©tiques

<br>

-   Tapez et ex√©cutez `2 + 3`.

-   Essayez d'autres op√©rateurs de calcul : `-`, `*`, `/`, ou `^`.

-   Calculez la racine carr√©e de 25 : `sqrt(x = 25)`.

<br>

‚ùìQuelle est la diff√©rence entre les deux valeurs 5 obtenues ?

## R est un calculateur !

<br>

```{r, echo=TRUE, eval=TRUE}
2 + 3
(59 + 73 + 2) * 5
1 / 200 * 30
sin(pi / 2)
10^12 * sqrt(4312)
log(exp(5))
```

## Fonctions

<br>

![](img/fonctions_01.png){fig-align="center"}

## Fonctions

<br>

![](img/fonctions_02.png){fig-align="center"}

## Fonctions

<br>

R poss√®de une large collection de **fonctions int√©gr√©es** qu'on utilise comme ceci :

<br>

```{r, echo=TRUE, eval=FALSE}
function_name(arg1 = val1, arg2 = val2, ...)
```

<br>

Nous avons d√©j√† vu certaines fonctions dans les exercices pr√©c√©dents :

**`+`, `-`, `*`, `^`, `sqrt()`, `log()` sont toutes des fonctions.**

## Fonctions

<br>

```{r, echo=TRUE, eval=FALSE}
sqrt()
log()
sin()
exp()
mean()
```

<br>

```{r, echo=TRUE, eval=TRUE}
sqrt(x = 25)
```

## Fonctions infixes

<br>

```{r, echo=TRUE, eval=FALSE}
+
-
^
%%
%in%
```

<br>

### Op√©rateur unaire (fonction √† un seul argument)

```{r, echo=TRUE, eval=TRUE}
-1
```

<br>

### Op√©rateur binaire (fonction √† deux arguments)

```{r, echo=TRUE, eval=TRUE}
12 %% 5
```

## Corps d'une fonction

<br>

```{r, echo=TRUE, eval=TRUE}
log
mean
methods(mean)
`+`
read.csv
```

## Corps d'une fonction

<br>

```{r, echo=TRUE, eval=TRUE}
read.table
```

## Arguments d'une fonction

<br>

```{r, echo=TRUE, eval=TRUE}
log(x = 25)  ## `base = exp(1)` par d√©faut
log(x = 25, base = 10)
log10(x = 25)  ## √©quivalent de `log(x, base = 10)`
log2(x = 25)  ## √©quivalent de `log(x, base = 2)`
```

## Apprendre √† utiliser une fonction

<br>

```{r, echo=TRUE, eval=FALSE}
help(log)
?log
# curseur + F1
```

<br>

#### Description

`log`¬†computes logarithms, by default natural logarithms,¬†`log10`¬†computes common (i.e., base 10) logarithms, and¬†`log2`¬†computes binary (i.e., base 2) logarithms. The general form¬†`log(x, base)`¬†computes logarithms with base¬†`base`.

#### Apprendre √† utiliser une fonction

<br>

```{r, echo=TRUE, eval=FALSE}
help(log)
?log
# curseur + F1
```

<br>

### Usage

```{r, echo=TRUE, eval=FALSE}
log(x, base = exp(1))
logb(x, base = exp(1))
log10(x)
log2(x)

log1p(x)

exp(x)
expm1(x)
```

## Apprendre √† utiliser une fonction

<br>

```{r, echo=TRUE, eval=FALSE}
help(log)
?log
# curseur + F1
```

<br>

### Arguments

`x` a numeric or complex vector.

`base` a positive or complex number: the base with respect to which logarithms are computed. Defaults to `e = exp(1)`.

## Assignation implicite

<br>

```{r, echo=TRUE, eval=TRUE}
log(x = 25, base = 5)
log(25, 5)  ## le 1er argument est `x`, le 2nd `base`
log(5, 25)  ## le 1er argument est `x`, le 2nd `base`
log(25, base = 5)  ## le 1er argument est `x`
log(base = 5, 25)  ## fonctionne, mais √† √©viter
log(base = 5, x = 25)  ## √™tre explicite quand on modifie l'ordre des arguments
```

## Assignation implicite : attention !

<br>

**Assignation explicite** :

```{r, echo=TRUE, eval=TRUE}
## l'exemple utilise des vecteurs (s√©quences de nombres entour√©es par `c()`)
quantile(x = c(5, 1, 3), probs = c(0.25, 0.5, 0.75))
```

**Assignation implicite par position** :

```{r, echo=TRUE, eval=TRUE}
quantile(c(5, 1, 3), c(0.25, 0.5, 0.75))
```

<br>

Des erreurs dans les positions peuvent poser probl√®me :

```{r, echo=TRUE, eval=TRUE, error=TRUE}
quantile(c(0.25, 0.5, 0.75), c(5, 1, 3))
quantile(c(0.25, 0.5, 0.75), c(0.95, 0.345, 1))
```

## Mise en pratique : arguments d'une fonction

<br>

Parmi les lignes de code suivantes, laquelle (ou lesquelles) retourneront une erreur ? Pourquoi ?

<br>

`log(x = 1)`

`log(x = "1")`

`log(x)`

`log(value = 1)`

`` log(`1`) ``

`log(1)`

## Mise en pratique : arguments d'une fonction

<br>

```{r, echo=TRUE, eval=TRUE, error=TRUE}
log(x = 1)
log(x = "1")
log(x)
log(value = 1)
log(`1`)
log(1)
```

# Assignation et objets

## Mise en pratique : assignation et objets

<br>

-   Tapez et ex√©cutez `x <- 1` puis `x`.

-   Ex√©cutez `x + 2`.

-   Ex√©cutez `x <- 5` puis √† nouveau `x + 2`.

<br>

‚ùìPourquoi la console n'affiche-t-elle rien apr√®s l'ex√©cution de `x <- 1` ?

‚ùìQuel r√¥le joue le symbole "fl√®che" `<-` ?

‚ùìQuelle est la valeur de `x` apr√®s √©x√©cution des trois lignes de code ?

‚ùìQue se passe-t-il si vous ex√©cutez `y <- x` ? Et `y <- x <- 2` ?

‚ùìEx√©cutez `y <- 2 <- x`. Que se passe-t-il ?

‚ùìPouvez-vous assigner une valeur et afficher le contenu de l'objet simultan√©ment ?

## Assignation et objets

<br>

![](img/objets_01.png){fig-align="center"}

## Assignation et objets

<br>

```{r, echo=TRUE, eval=TRUE}
x <- 1
x
x + 2
x <- 5
x + 2
x
```

## Assignation et objets

<br>

```{r, echo=TRUE, eval=TRUE, error=TRUE}
y <- x
y
y <- x <- 2
x
y
y <- 2 <- x
```

## L'environnement

<br>

Par d√©faut, les objets assign√©s existent dans l'**environnenemt global** appel√© `R_GlobalEnv`.

L'aper√ßu de tout ce que vous avec d√©fini se trouve dans le **panneau d'environnement**.

<br>

![](img/rstudio_env_01.png){fig-align="center"}

## L'environnement

<br>

Pour supprimer un objet de l'environnement, utilisez la fonction `rm()`.

```{r, echo=TRUE, eval=TRUE}
# rm(x)  ## juste pour montrer le code
```

<br>

Pour supprimer plusieurs objets √† la fois, cliquez sur l'**ic√¥ne "balai"** :

![](img/rstudio_env_02.png){fig-align="center" width="25%"}

<br>

-   en affichage liste, tous les objets de l'environnement seront supprim√©s

-   en affichage grille, cochez les objets √† supprimer avant de cliquer sur l'ic√¥ne

## Assigner et afficher des objets

<br>

```{r, echo=TRUE, eval=TRUE}
print(a <- 123)
show(a <- 123)
(a <- 123)
```

## Syntaxe des noms d'objets

<br>

De bons noms d'objets :

-   **doivent √™tre descriptifs** (pas trop compliqu√©s mais pr√©cis)

-   **doivent commencer par une lettre**

    -   ‚úÖ`val1` , ‚ùå `1val`, `.val1`

-   **peuvent contenir d'autres symboles** comme des nombres, des points ou des tirets `_` mais pas des tirets `-`

    -   ‚úÖ`val_1` , `val.1`‚ùå `val-1`

-   **doivent suivre une convention coh√©rente** et ne pas m√©langer diff√©rents styles

    -   ‚ùå `val1`, `val_2` et `val.3`

-   **ne doivent pas utiliser des noms r√©serv√©s** qui ont une fonction dans R

    -   ‚ùå `if`, `in` , `function`, `TRUE`, `FALSE`, `NA`, `NaN`

## Syntaxe des noms d'objets

<br>

Dans R, les noms sont **sensibles √† la casse** : `myvalues`, `myValues` et `MyValues` sont des objets diff√©rents !

## 

![Illustration de [Allison Horst](https://allisonhorst.com/)](img/naming_conventions.png){fig-align="center"}

## Syntaxe des noms d'objets

<br>

Tout est question de **lisibilit√©** - choisissez la syntaxe qui vous facilite la vie (et pensez aux personnes qui liront votre code !)

```{r, echo=TRUE, eval=FALSE}
i_prefer_snake_case
```

```{r, echo=TRUE, eval=FALSE}
otherPeopleLikeToUseCamelCase
```

```{r, echo=TRUE, eval=FALSE}
some.people.use.periods
```

```{r, echo=TRUE, eval=FALSE}
And_aFew.PeopleRENOUNCEconvention
```

<br>

```{r, echo=TRUE, eval=FALSE}
df_population_us
```

```{r, echo=TRUE, eval=FALSE}
dfPopulationUs
```

```{r, echo=TRUE, eval=FALSE}
df.population.us
```

```{r, echo=TRUE, eval=FALSE}
df_Population.US
```

## Syntaxe des noms d'objets

<br>

Noms potentiels d'objets :

-   `myvalue1`

-   `myValue1`

-   `MyValue1`

-   `my_value_1`

-   `my.value.1`

-   ... et toutes les combinaisons de minuscules, majuscules et symboles vues pr√©c√©demment

<br>

**Utilisez le style que vous pr√©f√©rez, mais soyez coh√©rents !**

## Syntaxe d'assignation

<br>

```{r, echo=TRUE, eval=TRUE}
name <- "Jo"  ## assignation gauche
name
"Clermont-Ferrand" -> city  ## assignation droite
city
pays = "France"  ## un `=` simple peut aussi servir pour assigner
pays
```

**üí°L'utilisation du `=` est controvers√©e car source de confusion, mais beaucoup plus r√©pandue dans d'autres langages de programmation.**

<br>

```{r, echo=TRUE, eval=TRUE, error=TRUE}
pays == "France"  ## un double `=` compare deux valeurs !
langue == "Francais"  ## un double `=` compare deux valeurs !
log(25, base = 5)  ## dans une fonction un `=` simple d√©finit les arguments
```

## Utiliser des objets dans des fonctions

<br>

`one <- 1`

`log(one)`

## Utiliser des objets dans des fonctions

<br>

```{r, echo=TRUE, eval=TRUE, error=TRUE}
one <- 1
one
log(one)
one <- "1"
one
log(one)
```

# Types de donn√©es

## Types de donn√©es

<br>

Il existe plusieurs types de donn√©es basiques dans R : **cha√Ænes de** **caract√®res**, **nombres r√©els**, **nombres entiers**, **nombres complexes**, et **op√©rateurs logiques**.

```{r, echo=TRUE, eval=TRUE}
typeof("Texte")
typeof(1)
typeof(1L)
typeof(1i)
typeof(TRUE)
```

<br>

Chacun de ces types de donn√©es poss√®de ses propres **caract√©ristiques** et **cas d'usage**.

## Types de donn√©es et classes atomiques

<br>

```{r, echo=TRUE, eval=TRUE}
typeof(1)
class(1)
typeof(1L)
class(1L)
typeof(1i)
class(1i)
```

<br>

M√™me si "integer" et "complex" sont des classes sp√©cifiques dans R, elles sont consid√©r√©es comme des sous-classes de la classe plus g√©n√©rale "numeric".

## Coercition en d'autres types de donn√©es

<br>

Les fonctions `as.*()` vous permettent de changer le type de donn√©es d'une valeur :

```{r, echo=TRUE, eval=TRUE}
as.character(1)
as.integer(1)
as.complex(1)
as.logical(1)
as.logical(0)
```

## Dates et heures

<br>

```{r, echo=TRUE, eval=TRUE}
typeof("2023-09-11 14:00:00")
```

<br>

#### Objets "Date"

```{r, echo=TRUE, eval=TRUE}
as.Date("2023-09-11 14:00:00")
typeof(as.Date("2023-09-11 14:00:00"))
```

<br>

#### Objets "POSIX" (Portable Operating System Interface)

```{r, echo=TRUE, eval=TRUE}
as.POSIXct("2023-09-11 14:00:00")  ## ct = calendar time
typeof(as.POSIXct("2023-09-11 14:00:00"))
as.POSIXlt("2023-09-11 14:00:00")  ## lt = local time
```

## Dates et heures

<br>

```{r, echo=TRUE, eval=TRUE, error=TRUE}
date <- "11.09.2023 14:00"
as.POSIXct(date)
```

```{r, echo=TRUE, eval=TRUE}
as.POSIXct(date, format = "%d.%m.%Y %H:%M")
as.POSIXct(date, format = "%d.%m.%Y %H:%M", tz = "EST")
as.POSIXct(date, format = "%d.%m.%Y %H:%M", tz = "Europe/Paris")
as.POSIXct(date, format = "%d.%m.%Y %H:%M", tz = "America/New_York")
```

# Valeurs manquantes

## "Not available"

<br>

**NA** est une valeur sp√©ciale utilis√©e pour repr√©senter une **donn√©e manquante ou ind√©finie**.

```{r, echo=TRUE, eval=TRUE}
typeof(NA)
typeof(NA_character_)
typeof(NA_integer_)
typeof(NA_real_)
typeof(NA_complex_)
```

## "Not a number"

<br>

La valeur **NaN** est une autre valeur sp√©ciale utilis√©e pour repr√©senter des **valeurs ind√©finies dans des op√©rations math√©matiques** :

```{r, echo=TRUE, eval=TRUE}
NaN
```

<br>

... comme le r√©sultat de la division de 0 par 0 :

```{r, echo=TRUE, eval=TRUE, error=TRUE}
0 / 0
is.nan(0 / 0)
is.na(0 / 0)
```

## Valeurs inconnues

<br>

Comme elles sont inconnues, **les valeurs sp√©ciales NA et NaN ne sont √©gales √† aucune autre valeur, y compris elles-m√™mes** :

```{r, echo=TRUE, eval=TRUE, error=TRUE}
NA == "Jo"
NaN == 1
NA == NA
NaN == (0 / 0)
```

<br>

Vous ne pouvez assigner aucune valeur aux valeurs sp√©ciales NA et NaN :

```{r, echo=TRUE, eval=TRUE, error=TRUE}
NA <- 1
```

# Vecteurs

## Mise en pratique : calculer une moyenne

<br>

-   Calculez la moyenne de ces trois valeurs num√©riques : 140, 97, et 222.

üí°Utilisez la fonction `mean()`.

## Mise en pratique : calculer une moyenne

<br>

-   Calculez la moyenne de ces trois valeurs num√©riques : 140, 97, et 222.

üí°Utilisez la fonction `mean()`.

<br>

```{r, echo=TRUE, eval=TRUE}
mean(140, 97, 222)
```

## Vecteurs

<br>

![](img/vector_01.png){fig-align="center"}

## Mise en pratique : calculer une moyenne

<br>

-   Calculez la moyenne de ces trois valeurs num√©riques : 140, 97, et 222.

üí°Utilisez la fonction `mean()`.

<br>

```{r, echo=TRUE, eval=TRUE}
mean(140, 97, 222)
```

```{r, echo=TRUE, eval=TRUE}
mean(c(140, 97, 222))
```

```{r, echo=TRUE, eval=TRUE}
values <- c(140, 97, 222)
mean(values)
```

```{r, echo=TRUE, eval=TRUE}
values <- c(140L, 97L, 222L)
mean(values)
```

## Mais ... J'√©tais suppos√© le deviner ?

<br>

```{r, echo=TRUE, eval=FALSE}
help(mean)
?mean
# curseur + F1
```

<br>

#### Usage

```{r, echo=TRUE, eval=FALSE}
mean(x, ...)

## Default S3 method:
mean(x, trim = 0, na.rm = FALSE, ...)
```

<br>

#### Examples

```{r, echo=TRUE, eval=TRUE}
x <- c(0:10, 50)
x
xm <- mean(x)
xm
```

## Vecteurs

<br>

Comme c'est le cas pour les valeurs, **les vecteurs peuvent √™tre de diff√©rents types** :

```{r, echo=TRUE, eval=TRUE}
ids <- 1:5
ids
typeof(ids)
```

<br>

```{r, echo=TRUE, eval=TRUE}
names <- c("Lucky Luke", "Averell", "Jack", "Joe", "Wiliam")
names
typeof(names)
```

## Vecteurs nomm√©s

<br>

```{r, echo=TRUE, eval=TRUE}
(colors <- c(green= "#28A87D", purple = "#9C55E3", yellow = "#EFAC00"))
```

<br>

Vous pouvez √©galement cr√©er un vecteur non nomm√© et ajouter les noms √† l'aide de **`names(x)`** :

```{r, echo=TRUE, eval=TRUE}
colors <- c("#28A87D", "#9C55E3", "#EFAC00")
colors
names(colors) <- c("green", "purple", "yellow")
colors
```

<br>

Pour supprimer les noms, utilisez **`unname()`** :

```{r, echo=TRUE, eval=TRUE}
unname(colors)
```

## Acc√©der aux √©l√©ments de vecteurs

<br>

```{r, echo=TRUE, eval=TRUE}
names
names[1]
names[2:3]
names[c(1:2, 4)]
names[-2]
```

## Acc√©der aux √©l√©ments de vecteurs nomm√©s

<br>

```{r, echo=TRUE, eval=TRUE}
colors
colors[c(1, 3)]
```

<br>

Les vecteurs nomm√©s peuvent √©galement √™tre explor√©s par **noms d'√©l√©ments** :

```{r, echo=TRUE, eval=TRUE}
colors["purple"]
colors[c("green", "yellow")]
```

## NA et NaN dans des vecteurs

<br>

Quand un NA est pr√©sent dans un vecteur, son type est d√©termin√© par les autres √©l√©ments du vecteur.

<br>

üí°Pas besoin de sp√©cifier `NA_character` par exemple.

<br>

```{r, echo=TRUE, eval=TRUE}
x <- c(1, 2, 3, NA, 5)
y <- c("A", "B", NA, "D", "E")
```

<br>

```{r, echo=TRUE, eval=TRUE}
typeof(x)
typeof(y)
```

## NA et NaN dans des vecteurs

<br>

Comme ils sont inconnus, toute op√©ration math√©matique retournera `NA` ou `NaN` :

```{r, echo=TRUE, eval=TRUE}
x <- c(5, 12, NA, 2, 18)
mean(x)
```

<br>

```{r, echo=TRUE, eval=TRUE}
y <- c(6, 23, NaN, 2, 18)
mean(y)
```

<br>

L'argument `na.rm` permet d'ignorer les valeurs inconnues :

```{r, echo=TRUE, eval=TRUE}
mean(x, na.rm = TRUE)  ## par d√©faut `na.rm = FALSE`
mean(y, na.rm = TRUE)
```

## Extension et combinaison de vecteurs

<br>

```{r, echo=TRUE, eval=TRUE}
colors_ext <- c(colors, "#000000", "#ffffff")
colors_ext
```

<br>

```{r, echo=TRUE, eval=TRUE}
colors_ext <- c(colors, c(black = "#000000", white = "#ffffff"))
colors_ext
```

<br>

```{r, echo=TRUE, eval=TRUE}
comb_vec <- c(ids, names)
comb_vec
```

Notez que dans le dernier exemple **toutes les valeurs prennent le m√™me type de donn√©es** (les vecteurs atomiques ne contiennent qu'un seul type de donn√©es).

## Coercition

<br>

Un vecteur atomique ne contient qu'un seul type de donn√©es.

Toutes les valeurs seront **implicement contraintes** au m√™me type de donn√©es :

<br>

```{r, echo=TRUE, eval=TRUE}
v1 <- c("ggplot2", 2023, TRUE)
v1
typeof(v1)
```

<br>

```{r, echo=TRUE, eval=TRUE}
v2 <- c(0.2, 1L, 3 + 0i)
v2
typeof(v2)
```

## Coercition

<br>

L'ordre de coercition est le suivant :

**`logical ‚ûô integer ‚ûô double ‚ûô complex ‚ûô character`**

<br>

```{r, echo=TRUE, eval=TRUE}
typeof(c(TRUE))
typeof(c(TRUE, 1L))
typeof(c(TRUE, 1L, 0.2))
typeof(c(TRUE, 1L, 0.2, 1 + 0i))
typeof(c(TRUE, 1L, 0.2, 1 + 0i, "a"))
```

## Coercition explicite

<br>

La coercition explicite permet de forcer les valeurs d'un vecteur atomique √† prendre un type de donn√©es sp√©cifique :

```{r, echo=TRUE, eval=TRUE}
v1
as.numeric(v1)
as.logical(v1)
```

## Coercition explicite

<br>

La coercition explicite permet de forcer les valeurs d'un vecteur atomique √† prendre un type de donn√©es sp√©cifique :

```{r, echo=TRUE, eval=TRUE}
v1
as.numeric(v1)
as.logical(v1)
```

<br>

Notez que **tous les nombres √† l'exception de `0`** deviennent **`TRUE`** :

```{r, echo=TRUE, eval=TRUE}
as.logical(2023)
```

## Coercition explicite

<br>

La coercition explicite permet de forcer les valeurs d'un vecteur atomique √† prendre un type de donn√©es sp√©cifique :

```{r, echo=TRUE, eval=TRUE}
v1
as.numeric(v1)
as.logical(v1)
```

<br>

Notez que **tous les nombres √† l'exception de `0`** deviennent `TRUE` :

```{r, echo=TRUE, eval=TRUE}
as.logical(2023)
```

... et **toutes les cha√Ænes de caract√®res √† l'exception de** `"TRUE"`, `"FALSE"`, `"T"` et `"F"` deviennent `NA` :

```{r, echo=TRUE, eval=TRUE}
as.logical("2023")
```

## Coercition explicite

<br>

La coercition explicite permet de forcer les valeurs d'un vecteur atomique √† prendre un type de donn√©es sp√©cifique :

<br>

```{r, echo=TRUE, eval=TRUE}
v2
as.integer(v2)
as.character(v2)
as.logical(v2)
as.logical(as.character(v2))
as.logical(as.integer(v2))
```

## Mise en pratique : coercition de vecteurs

<br>

-   Sans ex√©cuter le code, essayez de pr√©voir ce que retourneront les lignes de code suivantes :

`a <- c(1.7, "1.7")` et `as.numeric(a)`

`b <- c(TRUE, 2022, 1.375)` et `as.logical(as.complex(b))`

`c <- c(TRUE, "t", "TRUE", "T")` et `as.logical(c)`

`as.integer(c(45L, 0.237, 4.9))`

<br>

‚ùìQue retourne le code `as.factor(c("red", "blue"))` ?

## Mise en pratique : coercition de vecteurs

<br>

```{r, echo=TRUE, eval=TRUE}
a <- c(1.7, "1.7")
as.numeric(a)
b <- c(TRUE, 2022, 1.375)
as.logical(as.complex(b))
c <- c(TRUE, "t", "TRUE", "T")
as.logical(c)
as.integer(c(45L, 0.237, 4.9))
```

<br>

```{r, echo=TRUE, eval=TRUE}
c("red", "blue")
as.factor(c("red", "blue"))
```

# Facteurs

## Facteurs

<br>

Les facteurs repr√©sentent des donn√©es cat√©gorielles dans un **ordre sp√©cifique** :

```{r, echo=TRUE, eval=TRUE}
(v <- c("bien", "neutre", "mauvais"))
as.factor(v)
factor(v)
factor(v, levels = c("bien", "neutre", "mauvais"))
factor(v, levels = rev(v))
```

<br>

üí°Par d√©faut, les niveaux d'un facteur sont tri√©s **par ordre alphab√©tique**.

## Facteurs

<br>

... m√™me si la variable est encod√©e par des nombres :

```{r, echo=TRUE, eval=TRUE}
(n <- 0:3)
(f <- factor(n))
(f <- factor(n, levels = c(1:3, 0)))
mean(n)
mean(f)
```

## Niveaux et √©tiquettes de facteurs

<br>

`levels()` retourne les niveaux uniques dans l'ordre sp√©cifi√© :

```{r, echo=TRUE, eval=TRUE}
levels(f)
```

<br>

Vous pouvez aussi pr√©ciser des √©tiquettes qui √©crasent les valeurs d'origine :

```{r, echo=TRUE, eval=TRUE}
(ff <- factor(n, levels = c(1:3, 0), labels = c("mauvais", "neutre", "bien", "n/a")))
levels(ff)
```

## Coercition de facteurs

<br>

```{r, echo=TRUE, eval=TRUE}
ff
```

<br>

Pour transformer un facteur en nombres, utilisez `as.numeric()` :

```{r, echo=TRUE, eval=TRUE}
as.numeric(ff)
```

Notez que ceci retourne les √©l√©ments du facteur comme nombres selon les positions des niveaux !

<br>

Pour transformer √† nouveau en cha√Ænes de caract√®res, utilisez `as.character()` :

```{r, echo=TRUE, eval=TRUE}
as.character(ff)
```

## Coercition de facteurs : attention !

<br>

```{r, echo=TRUE, eval=TRUE}
f
```

<br>

Retourne des nombres selon les niveaux :

```{r, echo=TRUE, eval=TRUE}
as.numeric(f)
```

<br>

Retourne des nombres selon les √©l√©ments :

```{r, echo=TRUE, eval=TRUE}
as.numeric(as.character(f))
```

# Packages

## Qu'est-ce qu'un package ?

<br>

Un package est une **collection de fonctions, donn√©es, et autres objets** qui sont con√ßus pour effectuer des **t√¢ches sp√©cifiques** ou r√©soudre certains probl√®mes.

<br>

Ces packages sont cr√©√©s et maintenus par la communaut√© R, et sont souvent partag√©s sur le [Comprehensive R Archive Network (**CRAN**)](https://cran.r-project.org/) ou d'autres d√©p√¥ts comme [**BioConductor**](https://www.bioconductor.org/).

## Installer des packages suppl√©mentaires

<br>

Pour utiliser les fonctionnalit√©s d'un package sp√©cifique, vous devez d'abord **installer le package** sur votre ordinateur :

<br>

```{r, echo=TRUE, eval=FALSE}
install.packages("forcats")
## fournit des fonctions pour travailler avec des facteurs
```

```{r, echo=TRUE, eval=FALSE}
install.packages("palmerpenguins")
## contient des jeux de donn√©es utiles pour l'apprentissage
```

## Utiliser des packages : charger les librairies

<br>

Pour utiliser les fonctionnalit√©s d'un package install√©, vous devez **charger le package** :

<br>

```{r, echo=TRUE, eval=TRUE}
library(forcats)
```

<br>

```{r, echo=TRUE, eval=TRUE}

f <- factor(0:10)
levels(f)
fct_rev(f)
fct_relevel(f, "0", after = Inf)
```

## Utiliser des packages : charger les librairies

<br>

Pour utiliser les fonctionnalit√©s d'un package install√©, vous devez **charger le package** :

<br>

```{r, echo=TRUE, eval=TRUE}
library(palmerpenguins)
```

<br>

```{r, echo=TRUE, eval=TRUE}
penguins
```

## Utiliser des packages : conflits

<br>

Notez que dans certains cas, plusieurs packages peuvent contenir des fonctions (ou des jeux de donn√©es) portant **le m√™me nom**.

```{r, echo=TRUE, eval=FALSE}
install.packages("dplyr")
```

```{r, echo=TRUE, eval=TRUE}
library(dplyr)
## fournit des fonctions pour manipuler des donn√©es tabulaires
```

<br>

Si vous chargez deux fonctions portant le m√™me nom, la fonction du package **charg√© en dernier** sera utilis√©e !

## Utiliser des packages : Namespace

<br>

![](img/namespace.png){fig-align="center"}

## Utiliser des packages : Namespace

<br>

Pour √©viter les conflits, il est possible de faire r√©f√©rence **explicitement** √† des fonctions sp√©cifiques √† l'aide de **namespaces** :

<br>

```{r, echo=TRUE, eval=FALSE}
install.packages("stringr")
## fournit des fonctions pour travailler avec des cha√Ænes de caract√®res
```

```{r, echo=TRUE, eval=TRUE}
stringr::str_to_sentence(c("cafe", "latte machiatto", "expresso"))
```

<br>

Les namespaces permettent :

-   de **r√©soudre les conflits** dans les noms de fonctions

-   d'utiliser des fonctions **sans charger toutes les fonctionnalit√©s** d'un package

-   d'√™tre explicite pour les **fonctions non basiques**

# Donn√©es tabulaires

## Data Frames

<br>

Vous pouvez stocker plusieurs vecteurs, avec diff√©rents types de donn√©es, dans un **data frame** :

```{r, echo=TRUE, eval=TRUE}
(df_bd <- data.frame(ids, names))
```

<br>

Vous pouvez expliciter les **noms des colonnes** :

```{r, echo=TRUE, eval=TRUE}
(df_bd <- data.frame(id = ids, personnages = names))
```

## Acc√©der aux √©l√©ments d'un Data Frame

<br>

#### Lignes :

```{r, echo=TRUE, eval=TRUE}
df_bd[2, ]
```

<br>

#### Colonnes :

```{r, echo=TRUE, eval=TRUE}
df_bd[, 2]
df_bd$personnages
df_bd[[2]]
```

## Acc√©der aux √©l√©ments d'un Data Frame

<br>

#### Cellules :

```{r, echo=TRUE, eval=TRUE}
df_bd$personnages[2]
df_bd[[2]][2]
df_bd[, 2][2]
df_bd[2, 2]
```

## Acc√©der aux √©l√©ments d'un Data Frame

<br>

Les Data Frames supportent la **correspondance partielle** :

```{r, echo=TRUE, eval=TRUE}
df_bd
```

<br>

La colonne `perso` n'existe pas dans `df_bd` mais ressemble √† `personnages` :

```{r, echo=TRUE, eval=TRUE}
df_bd$perso
```

## Le Data Frame moderne : le Tibble

<br>

> Les Tibbles sont une refonte moderne du data.frame, conservant ce que le temps a montr√© √™tre efficace, et supprimant ce qui ne l'√©tait pas.

<br>

```{r, echo=TRUE, eval=FALSE}
install.packages("tibble")
```

```{r, echo=TRUE, eval=TRUE}
(tbl_bd <- tibble::tibble(id = ids, personnages = names))
```

<br>

Comme les fonctions utilis√©es pr√©c√©demment, `tibble()` est une fonction. Alors que `mean()` et `+` sont des fonctions de base, `tibble()` appartient √† un **package** ajout√© qui s'appelle √©galement **{tibble}**.

## Data Frame vs Tibble

<br>

> Les Tibbles sont une refonte moderne du data.frame, conservant ce que le temps a montr√© √™tre efficace, et supprimant ce qui ne l'√©tait pas.

<br>

Principales diff√©rences :

-   **l'affichage des tibbles est "affin√©"** :

    -   les 10 premi√®res lignes + toutes les colonnes qui rentrent sur l'√©cran

    -   pour chaque colonne : nom + type de donn√©es

    -   dimensions

## Data Frame vs Tibble

<br>

L'affichage des tibbles est "affin√©" :

<br>

```{r, echo=TRUE, eval=TRUE}
df_long <- data.frame(id = 1:100, value = sample(1:100, 100, replace = TRUE))
tbl_long <- tibble::tibble(id = 1:100, value = sample(1:100, 100, replace = TRUE))
```

<br>

::: columns
::: column
```{r, echo=TRUE, eval=TRUE}
df_long
```
:::

::: column
```{r, echo=TRUE, eval=TRUE}
tbl_long
```
:::
:::

## Mise en pratique : Data Frame vs Tibble

<br>

Comparez l'affichage du jeu de donn√©es penguins au format Data Frame et au format Tibble :

<br>

`as.data.frame(penguins)`

<br>

`tibble::as_tibble(penguins)`

## Data Frame vs Tibble

<br>

> Les Tibbles sont une refonte moderne du data.frame, conservant ce que le temps a montr√© √™tre efficace, et supprimant ce qui ne l'√©tait pas.

<br>

Principales diff√©rences :

-   **l'affichage des tibbles est "affin√©"** :

    -   les 10 premi√®res lignes + toutes les colonnes qui rentrent sur l'√©cran

    -   pour chaque colonne : nom + type de donn√©es

    -   dimensions

-   **la s√©lection de sous-ensembles de donn√©es est plus stricte pour les tibbles**

::: columns
::: column
```{r, echo=TRUE, eval=TRUE, error=TRUE}
df_long$val
```
:::

::: column
```{r, echo=TRUE, eval=TRUE, error=TRUE}
tbl_long$val
```
:::
:::

## Explorer un jeu de donn√©es

<br>

Pour afficher un tableau √† la mani√®re d'un tableur Excel :

<br>

```{r, echo=TRUE, eval=FALSE}
View(tbl_long)
```

## Explorer un jeu de donn√©es

<br>

```{r, echo=TRUE, eval=TRUE}
head(tbl_long)  ## 6 premi√®res lignes
tail(tbl_long)  ## 6 derni√®res lignes
head(tbl_long, n = 3)  ## 3 premi√®res lignes
```

## Explorer un jeu de donn√©es

<br>

```{r, echo=TRUE, eval=TRUE}
dim(tbl_long)  ## dimensions (nb lignes x nb colonnes)
str(tbl_long)  ## dimensions + contenu
tibble::glimpse(tbl_long)  ## dimensions + contenu (format tibble)
summary(tbl_long)  ## statistiques
```

## Explorer un jeu de donn√©es

<br>

```{r, echo=TRUE, eval=TRUE}
mean(tbl_long$value)  ## moyenne
range(tbl_long$value)  ## min et max
unique(tbl_long$value)  ## valeurs uniques
sort(unique(tbl_long$value))  ## valeurs uniques tri√©es
length(tbl_long$value)  ## nombre d'observations
length(unique(tbl_long$value))  ## nombre d'observations uniques
```

## Mise en pratique : donn√©es tabulaires

::: {.callout-tip appearance="simple" icon="false"}
-   Si ce n'est pas encore fait, installez et chargez le package {palmerpenguins}

-   Explorez le jeu de donn√©es `penguins` :

    -   nombre d'observations

    -   comptez le nombre d'observations par sexe

    -   v√©rifiez les ann√©es de suivi des pingouins

    -   calculez la longueur moyenne des becs (bill length)

    -   affichez les quantiles des mesures de la longueur des ailes (flipper length)

    -   stockez la colonne de masse corporelle (body mass) dans un vecteur `penguin_weights`
:::

## Mise en pratique : travailler avec des donn√©es tabulaires

```{r, echo=TRUE, eval=TRUE}
dim(penguins)  ## ou `nrow(penguins)`, `length(penguins$species)`, ...
summary(penguins$sex)
unique(penguins$year)
mean(penguins$bill_length_mm)
mean(penguins$bill_length_mm, na.rm = TRUE)
quantile(penguins$flipper_length_mm, na.rm = TRUE)
penguins_weights <- penguins$body_mass_g
```

## Listes

La liste est de loin la structure de donn√©es la plus flexible dans R. Une liste est une collection d'√©l√©ments sans aucune restriction de classe, longueur ou structure de chaque √©l√©ment.

```{r, echo=TRUE, eval=TRUE}
my_list <- list(ids = 1:5, names = c("Joe", "Jack", "William", "Averell", "Rantanplan"))
my_list
```

Notez que les data frames peuvent √™tre √©galement consid√©r√©s comme des listes tabulaires simples.

## Acc√©der aux √©l√©ments d'une liste

```{r, echo=TRUE, eval=TRUE}
my_list$names
my_list$names[1]
my_list[[2]]
my_list[[2]][1]
```

## Listes imbriqu√©es

Habituellement, on entend par listes des structures de donn√©es imbriqu√©es

```{r, echo=TRUE, eval=TRUE}
my_nested_list <- list(
  ids = list(1:5, 1),
  names = list(c("Lucky Luke", "Joe", "Jack", "William", "Averell"),
               "Rantanplan"),
  type = list(rep("humain", 5), "chien")
)
my_nested_list
```

## Listes imbriqu√©es

```{r, echo=TRUE, eval=TRUE}
my_nested_list$names
my_nested_list$names[[1]]
my_nested_list$names[[1]][1]
my_nested_list$names[[2]][[1]][1]
```

## Listes imbriqu√©es comme Tibbles

```{r, echo=TRUE, eval=TRUE}
my_tbl_list <- tibble::as_tibble(my_nested_list)
my_tbl_list
```

## D√©simbriquer des listes imbriqu√©es

```{r, echo=TRUE, eval=FALSE}
install.packages("tidyr")
```

```{r, echo=TRUE, eval=TRUE}
my_tbl <- tidyr::unnest(my_tbl_list)
my_tbl <- tidyr::unnest(my_tbl_list, cols = c(ids, names, type))
my_tbl
```

## Imbriquer des listes

```{r, echo=TRUE, eval=TRUE}
my_nested_tbl <- tidyr::nest(my_tbl, data = !type)
my_nested_tbl$data
```

# Cr√©er des jeux de donn√©es

## Cr√©er des ~~jeux de donn√©es~~ vecteurs dans R

Vous pouvez combiner des vecteurs dans un data frame ou un tibble. Les fonctions `seq()` et `rep()` sont utiles pour cr√©er des vecteurs :

```{r, echo=TRUE, eval=TRUE}
1:10
seq(from = 0, to = 150, by = 25)
0:6*25
seq(from = 0, to = 150, length.out = 5)
rep(1:3, times = 3)
rep(1:3, each = 3)
```

## Cr√©er des jeux de donn√©es dans R

Vous pouvez combiner des vecteurs dans un data frame ou un tibble. Les fonctions `seq()` et `rep()` sont utiles pour cr√©er des vecteurs :

```{r, echo=TRUE, eval=TRUE}
name <- c("Rantanplan", "Id√©fix", "Milou", "Bill", "Pif")
age <- seq(1, 13, by = 3)
species <- rep("chien", length(name))
id <- 1:length(name)
tibble::tibble(id, name, age, species)  ## ou `data.frame()`
```

## Cr√©er des jeux de donn√©es dans R

Vous pouvez cr√©er ces colonnes directement dans la fonction data.frame() ou tibble() :

```{r, echo=TRUE, eval=TRUE}
tibble::tibble(
  name = c("Rantanplan", "Id√©fix", "Milou", "Bill", "Pif"),
  age = seq(1, 13, by = 3),
  species = rep("chien", length(name)),
  id = 1:length(name)
)
```

## Cr√©er des jeux de donn√©es dans R

Vous pouvez √©galement cr√©er des tibbles en utilisant une disposition par ligne - un tribble :

```{r, echo=TRUE, eval=TRUE}
tibble::tribble(
  ~id, ~name,        ~age, ~species,
  1,   "Rantanplan", 1,    "chien",
  2,   "Id√©fix",     4,    "chien",
  3,   "Milou",      7,    "chien",
  4,   "Bill",       10,   "chien",
  5,   "Pif",        13,   "chien"
)
```

# Importer des donn√©es

## Le workflow en data science

![Le workflow en data science, modifi√© √† partir de "R for Data Science"](img/workflow_01.png)

## Le workflow en data science

![Le workflow en data science, modifi√© √† partir de "R for Data Science"](img/workflow_02.png)

## Importer des donn√©es

Habituellement, vous cr√©ez des data frames en important des fichiers de donn√©es comme `.txt`, `.csv`, ...

```{r, echo=TRUE, eval=FALSE}
my_data <- read.delim("./data/cool_data.txt", sep = "\t")
my_data <- read.csv("./data/cool_data.csv")
```

Le `./` d√©signe un chemin relatif, √† partir de votre **r√©pertoire de travail (working directory)**.

Vous pouvez v√©rifier votre "wd" √† l'aide de la fonction `getwd()`.

Vous pouvez aussi importer des donn√©es directement √† partir d'un site internet √† l'aide d'une URL valide :

```{r, echo=TRUE, eval=FALSE}
my_data <- read.csv("https:://some-webpage.com/online-data.csv")
```

## Importer des donn√©es : Tibbles

Le package {readr} fournit une m√©thode simple et rapide de lire des donn√©es rectangulaires stock√©es comme des tibbles :

```{r, echo=TRUE, eval=FALSE}
my_data <- readr::read_delim("./data/cool_data.txt", delim = "\t")
my_data <- readr::read_csv("./data/cool_data.csv")
my_data <- readr::read_csv2("./data/actually_not_a_csv_but_okay.csv")  ## `;` comme s√©parateur et "," comme d√©cimale
```

## Importer des donn√©es : fichiers Excel (pas id√©al)

Le package {readxl} fournit des fonctionnalit√©s pour importer des tableaux Excel :

```{r, echo=TRUE, eval=FALSE}
my_data <- readxl::read_xls("./data/oh_no_excel_data.xls", sheet = 1)
my_data <- readxl::read_xlsx("./data/oh_no_excel_data.xlsx", sheet = 1)
```

## Importer des donn√©es : formats propres √† R

Il existe √©galement des formats propres √† R comme .Rds et .Rdata / .Rda

```{r, echo=TRUE, eval=FALSE}
## R basique :
my_data <- readRDS("./data/one_of_Rs_data_formats.Rds")
```

```{r, echo=TRUE, eval=FALSE}
## package readr :
my_data <- readr::read_rds("./data/one_of_Rs_data_formats.Rds")
```

## Importer des donn√©es : trop lent ?

Le package {data.table} fournit des fonctionnalit√©s pour importer, exporter et manipuler des donn√©es.

Les fonctions pour importer et exporter des donn√©es sont connues pour √™tre tr√®s rapides :

```{r, echo=TRUE, eval=FALSE}
my_data <- data.table::fread("./data/cool_data.csv", sep = ",")
```
