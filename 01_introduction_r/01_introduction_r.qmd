---
format:
  revealjs:
    theme: custom.scss
    fontsize: 1.8em
editor: visual
title-slide-attributes: 
  data-background-image: img/title.png
  data-background-opacity: 50%
---

![](img/title.png){fig-align="center"}

# Introduction

## Qu'est-ce que R ?

<br>

R est un **langage de programmation** et un **logiciel** utilisé pour réaliser des calculs statistiques et des graphiques.

R a été conçu en 1992 par **Ross Ihaka** et **Robert Gentleman** comme implémentation open source du langage de programmation S et publié en 1995.

<br>

Depuis, les utilisations de R se sont largement diversifiées :

-   analyses statistiques et workflows de data science

-   visualisations graphiques avancées

-   rapports automatisés

-   applications web

-   diaporamas, livres, et pages web

## Pourquoi (pas) R ?

<br>

### **Avantages :**

-   libre, open source, et plateforme indépendant

-   large variété d'extensions proposant des fonctionnalités supplémentaires

-   compatible avec d'autres langages de programmation

-   puissant pour l'analyse et la visualisation de données

-   très large communauté en ligne

-   souvent expérimenté comme étant *simple à coder* (pour un novice)

## Pourquoi (pas) R ?

<br>

### **Inconvénients :**

-   performance : évolutivité, mémoire et vitesse

-   courbe d'apprentissage importante

-   potentiels problèmes de sécurité (applications web)

-   souvent expérimenté comme étant *étrange à coder* (pour un expert)

# R versus RStudio

## 

![Inspiré de [Modern Drive](https://moderndive.com/index.html)](img/r_vs_rstudio.png){fig-align="center" width="80%"}

<br>

-   **RStudio** est un environnement de développement intégré (IDE) open source

-   IDE pour R le plus populaire depuis plusieurs années

-   de nombreuses fonctionnalités et extensions pour faciliter les workflows (suivi de version, sommaire, add-ins, ...)

-   projets R et RMarkdown/Quarto

## Mise en pratique : installer R et RStudio

<br>

-   Télécharger et installer R depuis

    [cloud.r-project.org](https://cloud.r-project.org)

<br>

-   Télécharger et installer RStudio Desktop depuis

    [posit.co/download/rstudio-desktop](https:://posit.co/download/rstudio-desktop)

## 

![](img/r_windows.png){fig-align="center"}

## 

![](img/r_studio_01.png){fig-align="center"}

## 

![](img/r_studio_02.png){fig-align="center"}

## Console et script

<br>

-   La **console** vous permet de taper du code et de l'exécuter.

    -   le code tapé dans la console sera perdu quand vous quitterez R ...

    -   ... ce qui est problématique pour sauvegarder et partager votre code !

<br>

-   Un **script**, à la manière d'un document texte, vous permet de sauvegarder votre code et de le partager.

<br>

-   Dans la console, le code est tapé à la suite de l'**invite de commande `>`**.

-   La console affiche la **sortie** (le résultat) du code à la ligne suivante (débute par `[1]`).

-   Le code exécuté à partir d'un script s'affiche dans la console.

## Mise en pratique : console et script

<br>

-   Ouvrez **R**, tapez les commandes suivantes et appuyez sur `Entrée` pour les exécuter :

    -   `"Ceci est du texte"`

    -   `2 + 2`

<br>

-   Ouvrez **RStudio**

    -   Ouvrez un script (`File > New File > RScript`)

    -   Ajoutez les deux commandes ci-dessus et exécutez-les en plaçant le curseur à la fin de la première ligne et en cliquant sur `Run` (ou en utilisant le raccourci clavier `Ctrl + Entrée`)

    -   Sauvegardez le script (`Ctrl + S`)

## Les commentaires

<br>

Les commentaires servent à :

-   **inactiver** du code qu'on ne souhaite plus exécuter

-   ajouter des commentaires pour **expliquer** notre raisonnement

Dans R, les commentaires sont codés par un hash `#`.

Tout ce qui suit sur la même ligne ne sera pas traité comme du code.

<br>

Par convention, nous utilisons :

-   `#` pour commenter du code

-   `##` pour ajouter des commentaires :

```{r, echo=TRUE, eval=TRUE}
# "Ceci est du texte"  ## Cette ligne n'est plus utile
```

## Les commentaires

<br>

Prenez dès maintenant l'habitude de commenter vos scripts.

Cela les rendra plus **compréhensibles** - pour vous et pour vos collègues !

Les commentaires peuvent vous servir à créer un en-tête (quoi ? qui ? quand ?)

<br>

Les commentaires servent également à structurer un script et à afficher une table des matières, en ajoutant quatre tirets `-` après un titre :

![](img/toc_01.png){fig-align="center"}

## Mise en pratique : commenter un script

<br>

-   Ouvrez un nouveau script et renseignez les informations essentielles (quoi ? qui ? quand ?)

<br>

-   Ajouter deux titres de sections

## Mise en pratique : commenter un script

<br>

-   Ouvrez un nouveau script et renseignez les informations essentielles (quoi ? qui ? quand ?)

<br>

-   Ajouter deux titres de sections

<br>

```{r, echo=TRUE, eval=TRUE}
## Ateliers codons
## Premiers pas avec R
## NOM Prenom
## Date

## Section 1 ----
## Section 2 ----
```

## Mise en pratique : paramètres de RStudio

<br>

-   Cliquez sur `Help > Cheatsheets > RStudio IDE Cheat Sheet` et parcourez le document qui s'ouvre.

-   Cliquez sur `View > Panes > Pane Layout` et arrangez les panneaux selon votre préférence.

-   Cliquez sur `Tools > Global Options` et parcourez les différents éléments.

## 

![](img/r_studio_04.png){fig-align="center"}

## 

![](img/r_studio_05.png){fig-align="center"}

## 

![](img/r_studio_06.png){fig-align="center"}

## 

![](img/r_studio_07.png){fig-align="center"}

# Organiser son travail

## Les projets R

<br>

Les projets R (ou projets RStudio) vous fournissent un **workflow robuste** qui vous servira par la suite :

-   ils reposent sur l'idée que tous les fichiers associés à votre projet devraient être stockés **dans le même dossier**

    -   aide à (re)trouver les fichiers

    -   augmente la reproductibilité

    -   facilite la collaboration

-   le **répertoire de travail** est défini dans le dossier où se trouve le fichier .Rproj

    -   le répertoire de travail est clairement défini

    -   indépendant des paramètres du système d'opération et de l'arborescence des dossiers (propre à chaque utilisateur)

    -   limite les changements de répertoire lors de collaborations

## Mise en pratique : créer un projet

<br>

Pour créer un projet R : `File > New Project …`

![](img/r_projects_01.png){fig-align="center"}

## Mise en pratique : créer un projet

<br>

::: {layout-ncol="2"}
![](img/r_projects_02.png)

![](img/r_projects_03.png)
:::

# Valeurs

## Valeurs

Tapez les commandes suivantes :

`1`

`"Hello World!"`

`x`

`pi`

## Valeurs

```{r, echo=TRUE, eval=TRUE, error=TRUE}
1
"Hello World!"
x
pi
```

# Fonctions

## Mise en pratique : opérations arithmétiques

::: {.callout-tip appearance="simple" icon="false"}
-   Tapez `2 + 3 et exécutez.`

-   Essayez d'autres opérateurs de calcul comme `-`, `*`, `/`, ou `^`.

-   Calculez la racine carrée d'un nombre avec `sqrt()`.
:::

::: {.callout-caution appearance="simple" icon="false"}
-   Quelle est la différence entre la valeur 5 obtenue à la première ligne et le calcul de la racine carrée à l'aide de `sqrt` ?
:::

## R est un calculateur !

```{r, echo=TRUE, eval=TRUE}
2 + 3
(59 + 73 + 2) * 5
1 / 200 * 30
sin(pi / 2)
10^12 * sqrt(4312)
log(exp(5))
```

## Fonctions

![](img/fonctions_01.png){fig-align="center"}

## Fonctions

![](img/fonctions_02.png){fig-align="center"}

## Fonctions

R possède une large collection de fonctions intégrées qu'on appelle comme ceci :

```{r, echo=TRUE, eval=FALSE}
function_name(arg1 = val1, arg2 = val2, ...)
```

Nous avons déjà vu certaines fonctions dans les exercices précédents :

`+`, `-`, `*`, `^`, `sqrt()`, `log()` sont toutes des fonctions.

## Fonctions

```{r, echo=TRUE, eval=FALSE}
sqrt()
log()
sin()
exp()
mean()
```

<br>

```{r, echo=TRUE, eval=TRUE}
sqrt(x = 25)
```

## Fonctions infixes

```{r, echo=TRUE, eval=FALSE}
+
-
^
%%
%in%
```

<br>

### Opérateur unaire

```{r, echo=TRUE, eval=TRUE}
-1
```

<br>

### Opérateur binaire

```{r, echo=TRUE, eval=TRUE}
12 %% 5
```

## Corps d'une fonction

```{r, echo=TRUE, eval=TRUE}
log
mean
methods(mean)
`+`
read.csv
```

## Corps d'une fonction

```{r, echo=TRUE, eval=TRUE}
read.table
```

## Arguments d'une fonction

```{r, echo=TRUE, eval=TRUE}
log(x = 25)  ## `base = exp(1)` par défaut
log(x = 25, base = 10)
log10(x = 25)  ## équivalent de `log(x, base = 10)`
log2(x = 25)  ## équivalent de `log(x, base = 2)`
```

## Apprendre à utiliser une fonction

```{r, echo=TRUE, eval=FALSE}
help(log)
?log
# curseur + F1
```

### Description

`log` computes logarithms, by default natural logarithms, `log10` computes common (i.e., base 10) logarithms, and `log2` computes binary (i.e., base 2) logarithms. The general form `log(x, base)` computes logarithms with base `base`.

## Apprendre à utiliser une fonction

```{r, echo=TRUE, eval=FALSE}
help(log)
?log
# curseur + F1
```

### Usage

```{r, echo=TRUE, eval=FALSE}
log(x, base = exp(1))
logb(x, base = exp(1))
log10(x)
log2(x)

log1p(x)

exp(x)
expm1(x)
```

## Apprendre à utiliser une fonction

```{r, echo=TRUE, eval=FALSE}
help(log)
?log
# curseur + F1
```

### Arguments

`x` a numeric or complex vector.

`base` a positive or complex number: the base with respect to which logarithms are computed. Defaults to `e = exp(1)`.

## Arguments d'une fonction : assignation implicite

```{r, echo=TRUE, eval=TRUE}
log(x = 25, base = 5)
log(25, 5)  ## le 1er argument est `x`, le 2nd `base`
log(5, 25)  ## le 1er argument est `x`, le 2nd `base`
log(25, base = 5)  ## le 1er argument est `x`
log(base = 5, 25)  ## fonctionne, mais à éviter
log(base = 5, x = 25)  ## soyez explicites si vous souhaitez modifier les positions des arguments
```

## Assignation implicite : attention !

Noms d''arguments explicites :

```{r, echo=TRUE, eval=TRUE}
## l'exemple utilise des vecteurs (séquences de nombres entourées par `c()`)
quantile(x = c(5, 1, 3), probs = c(0.25, 0.5, 0.75))
```

Assignation implicite par position :

```{r, echo=TRUE, eval=TRUE}
quantile(c(5, 1, 3), c(0.25, 0.5, 0.75))
```

Des erreurs dans la modification des positions peut engendrer tout un tas de problèmes :

```{r, echo=TRUE, eval=TRUE, error=TRUE}
quantile(c(0.25, 0.5, 0.75), c(5, 1, 3))
quantile(c(0.25, 0.5, 0.75), c(0.95, 0.345, 1))
```

## Mise en pratique : arguments d'une fonction

::: {.callout-caution appearance="simple" icon="false"}
Quelles lignes de code ci-dessous vont fonctionner ?
:::

`log(x = 1)`

`log(x = "1")`

`log(x)`

`log(value = 1)`

`` log(`1`) ``

`log(1)`

# Assignation et objets

## Mise en pratique : assignation et objets

::: {.callout-tip appearance="simple" icon="false"}
-   Tapez et exécutez `x <- 1` puis `x`.

-   Exécutez `x + 2`.

-   Exécutez `x <- 5` puis à nouveau `x + 2`.
:::

::: {.callout-caution appearance="simple" icon="false"}
-   Pourquoi n'y a-t-il aucune sortie après exécution de `x <- 1` ?

-   Que fait le symbole de la flèche `<-` ?

-   Quelle est la valeur de `x` à la fin ?

-   Que se passe-t-il si vous exécutez `y <- x` ? Et `y <- x <- 2` ?

-   Tapez et exécutez `y <- 2 <- x`. Que se passe-t-il ?

-   Pouvez-vous assigner une valeur et montrer le contenu de l'objet en même temps ?
:::

## Assignation et objets

![](img/objets_01.png){fig-align="center"}

## Assignation et objets

```{r, echo=TRUE, eval=TRUE}
x <- 1
x
x + 2
x <- 5
x + 2
x
```

## Assignation et objets

```{r, echo=TRUE, eval=TRUE, error=TRUE}
y <- x
y
y <- x <- 2
x
y
y <- 2 <- x
```

## L'environnement

Par défaut, les objets assignés existent dans l'**environnenemt global** appelé `R_GlobalEnv`. L'aperçu de tout ce que vous avec défini se trouve dans le **panneau d'environnement**.

![](img/rstudio_env_01.png){fig-align="center"}

## Assigner et afficher des objets

```{r, echo=TRUE, eval=TRUE}
print(a <- 123)
show(a <- 123)
(a <- 123)
```

## Syntaxe des noms d'objets

-   devrait être descriptif

    -   équilibre entre l'effort pour taper et la précision

-   doit commencer par une lettre

    -   `val1` valide - `1val` et `.val1` non valides

-   peut contenir d'autres symboles dans le nom

    -   nombres, points, et/ou tirets \_ : `val_1`

    -   pas de tiret - (ne pas utiliser le style kebab, voir diapo suivante)

-   sensible à la casse

    -   `myvalues`, `myValues` et `MyValues` sont des objets différents !

-   doit dans l'idéal suivre une convention cohérente

    -   ne pas mélanger différents styles : éviter `val1`, `val_2` et `val.3`

-   ne peut pas utiliser des noms réservés qui ont une fonction dans R

    -   `if`, `in`, `function`, `TRUE`, `FALSE`, `NA`, `NaN`

## 

![Illustration de [Allison Horst](https://allisonhorst.com/)](img/naming_conventions.png){fig-align="center"}

## Syntaxe des noms d'objets

C'est une question de lisibilité - décidez par vous-mêmes :

```{r, echo=TRUE, eval=FALSE}
i_prefer_snake_case
```

```{r, echo=TRUE, eval=FALSE}
otherPeopleLikeToUseCamelCase
```

```{r, echo=TRUE, eval=FALSE}
some.people.use.periods
```

```{r, echo=TRUE, eval=FALSE}
And_aFew.PeopleRENOUNCEconvention
```

<br>

```{r, echo=TRUE, eval=FALSE}
df_population_us
```

```{r, echo=TRUE, eval=FALSE}
dfPopulationUs
```

```{r, echo=TRUE, eval=FALSE}
df.population.us
```

```{r, echo=TRUE, eval=FALSE}
df_Population.US
```

## Syntaxe des noms d'objets

Noms d'objets potentiels :

-   `myvalue1`

-   `myValue1`

-   `MyValue1`

-   `my_value_1`

-   `my.value.1`

-   ... et toutes les combinaisons de minuscules/majuscules et de symboles

Utilisez le style que vous préférez, mais soyez consistents !

## Syntaxe d'assignation

```{r, echo=TRUE, eval=TRUE}
name <- "Jo"
name
"Clermont-Ferrand" -> city  ## assignation à droite
city
pays = "France"  ## un `=` simple peut aussi servir pour assigner
pays
```

L'utilisation du `=` est controversée car source de confusion, mais beaucoup plus répandue dans d'autres langages de programmation.

```{r, echo=TRUE, eval=TRUE, error=TRUE}
pays == "France"  ## un double `=` compare deux valeurs !
langue == "Francais"  ## un double `=` compare deux valeurs !
log(25, base = 5)  ## dans une fonction un `=` simple définit les arguments
```

## Utiliser des objets dans des fonctions

`one <- 1`

`log(one)`

## Utiliser des objets dans des fonctions

```{r, echo=TRUE, eval=TRUE, error=TRUE}
one <- 1
one
log(one)
one <- "1"
one
log(one)
```

# Types de données

Il existe plusieurs types de données basiques dans R : character, double, integer, complex, et logical.

```{r, echo=TRUE, eval=TRUE}
typeof("Hello World!")
typeof(1)
typeof(1L)
typeof(1i)
typeof(TRUE)
```

Chacun de ces types de données possède ses propres caractéristiques et utilisations.

## Types de données et classes atomiques

```{r, echo=TRUE, eval=TRUE}
typeof(1)
class(1)
typeof(1L)
class(1L)
typeof(1i)
class(1i)
```

Même si "integer" et "complex" sont des classes spécifiques dans R, elles sont considérées comme des sous-types du type de données plus général "numeric".

## Coercition en d'autres types de données

Les fonctions `as.*()` vous permettent de changer le type de données d'une valeur :

```{r, echo=TRUE, eval=TRUE}
as.character(1)
as.integer(1)
as.complex(1)
as.logical(1)
as.logical(0)
```

## Dates et horodatages

```{r, echo=TRUE, eval=TRUE}
typeof("2023-09-11 14:00:00")
```

### Objets "Date"

```{r, echo=TRUE, eval=TRUE}
as.Date("2023-09-11 14:00:00")
typeof(as.Date("2023-09-11 14:00:00"))
```

### Objets "Datetime"

```{r, echo=TRUE, eval=TRUE}
as.POSIXct("2023-09-11 14:00:00")
typeof(as.POSIXct("2023-09-11 14:00:00"))
as.POSIXlt("2023-09-11 14:00:00")
```

## Dates et horodatages

```{r, echo=TRUE, eval=TRUE}
date <- "2023-09-11 14:00:00"
as.POSIXct(date)
```

```{r, echo=TRUE, eval=TRUE}
as.POSIXct(date, format = "%d.%m.%Y %H:%M")
as.POSIXct(date, format = "%d.%m.%Y %H:%M", tz = "EST")
as.POSIXct(date, format = "%d.%m.%Y %H:%M", tz = "America/New_York")
as.POSIXct(date, format = "%d.%m.%Y %H:%M", tz = "US/Eastern")
```

# Valeurs manquantes

## "Not available"

NA est une valeur spéciale utilisée pour représenter une donnée manquante on indéfinie.

```{r, echo=TRUE, eval=TRUE}
typeof(NA)
typeof(NA_character_)
typeof(NA_integer_)
typeof(NA_real_)
typeof(NA_complex_)
```

## "Not a number"

La valeur NaN est une autre valeur spéciale utilisée pour représenter des valeurs indéfinies dans des opérations mathématiques :

```{r, echo=TRUE, eval=TRUE}
NaN
```

... comme le résultat de la division de 0 par 0 :

```{r, echo=TRUE, eval=TRUE, error=TRUE}
0 / 0
is.nan(0 / 0)
is.na(0 / 0)
```

## Valeurs inconnues

Comme elles sont inconnues, les valeurs spéciales NA et NaN ne sont égales à aucune autre valeur, y compris elles-mêmes :

```{r, echo=TRUE, eval=TRUE, error=TRUE}
NA == "Jo"
NaN == 1
NA == NA
NaN == (0 / 0)
```

Vous ne pouvez assigner aucune valeur aux valeurs spéciales NA et NaN :

```{r, echo=TRUE, eval=TRUE, error=TRUE}
NA <- 1
```

# Vecteurs

## Mise en pratique : calculer des moyennes

::: {.callout-tip appearance="simple" icon="false"}
-   Calculez la moyenne de ces trois valeurs numériques : 140, 97, et 222
:::

```{r, echo=TRUE, eval=TRUE}
mean(140, 97, 222)
```

![](img/liar-mad.gif){fig-align="center"}

## Vecteurs

![](img/vector_01.png){fig-align="center"}

## Mise en pratique : calculer des moyennes

::: {.callout-tip appearance="simple" icon="false"}
-   Calculez la moyenne de ces trois valeurs numériques : 140, 97, et 222
:::

```{r, echo=TRUE, eval=TRUE}
mean(c(140, 97, 222))
```

## Mise en pratique : calculer des moyennes

::: {.callout-tip appearance="simple" icon="false"}
-   Calculez la moyenne de ces trois valeurs numériques : 140, 97, et 222
:::

```{r, echo=TRUE, eval=TRUE}
values <- c(140, 97, 222)
mean(values)

values <- c(140L, 97L, 222L)
mean(values)
```

## Mais ... Comment suis-je sensé savoir ?

```{r, echo=TRUE, eval=FALSE}
help(mean)
?mean
# curseur + F1
```

### Usage

```{r, echo=TRUE, eval=FALSE}
mean(x, ...)

## Default S3 method:
mean(x, trim = 0, na.rm = FALSE, ...)
```

### Examples

```{r, echo=TRUE, eval=TRUE}
x <- c(0:10, 50)
x
xm <- mean(x)
xm
```

## Vecteurs

Comme c'est le cas pour les valeurs, les vecteurs peuvent être de différents types :

```{r, echo=TRUE, eval=TRUE}
ids <- c(1:5)
ids
typeof(ids)
names <- c("Joe", "Jack", "William", "Averell", "Rantanplan")
names
typeof(names)
```

## Vecteurs nommés

```{r, echo=TRUE, eval=TRUE}
(couleurs <- c(vert = "#28A87D", violet = "#9C55E3", jaune = "#EFAC00"))
```

Vous pouvez également créer un vecteur non nommé et ajouter les noms à l'aide de `names(x)` :

```{r, echo=TRUE, eval=TRUE}
couleurs <- c("#28A87D", "#9C55E3", "#EFAC00")
names(couleurs) <- c("vert", "violet", "jaune")
couleurs
```

Pour supprimer les noms, utilisez `unname()` :

```{r, echo=TRUE, eval=TRUE}
unname(couleurs)
```

## Accéder aux éléments de vecteurs

```{r, echo=TRUE, eval=TRUE}
names
names[1]
names[2:3]
names[c(1:2, 4)]
names[-2]
```

## Accéder aux éléments de vecteurs nommés

```{r, echo=TRUE, eval=TRUE}
couleurs
couleurs[c(1, 3)]
```

Les vecteurs nommés peuvent également être explorés par noms d'éléments :

```{r, echo=TRUE, eval=TRUE}
couleurs["violet"]
couleurs[c("vert", "jaune")]
```

## NA et NaN dans des vecteurs

Quand il est utilisé dans un vecteur, le type de `NA` est déterminé par les types de données des autres valeurs - pas besoin de spécifier par exemple `NA_character_` :

```{r, echo=TRUE, eval=TRUE}
x <- c(1, 2, 3, NA, 5)
y <- c("A", "B", NA, "D", "E")
typeof(x)
typeof(y)
```

## NA et NaN dans des vecteurs

Comme ils sont inconnus, toute opération mathématique retournera `NA` ou `NaN` :

```{r, echo=TRUE, eval=TRUE}
x <- c(5, 12, NA, 2, 18)
mean(x)
y <- c(6, 23, NaN, 2, 18)
mean(y)
```

Pour ignorer les valeurs inconnues, vous pouvez définir l'argument `na.rm` comme `TRUE` :

```{r, echo=TRUE, eval=TRUE}
mean(x, na.rm = TRUE)  ## par défaut `na.rm = FALSE`
mean(y, na.rm = TRUE)
```

## Extension et combinaison de vecteurs

```{r, echo=TRUE, eval=TRUE}
couleurs_ext <- c(couleurs, "#000000", "#ffffff")
couleurs_ext
couleurs_ext <- c(couleurs, c(noir = "#000000", blanc = "#ffffff"))
couleurs_ext
```

```{r, echo=TRUE, eval=TRUE}
comb_vec <- c(ids, mean)
comb_vec
```

Notez que dans le dernier exemple **toutes les valeurs prennent le même type de données** (les vecteurs atomiques ne contiennent qu'un seul type de données)

## Coercition

Les vecteurs atomiques ne contiennent qu'un seul type de données et **toutes les valeurs sont implicitement contraintes à prendre le même type de données** :

```{r, echo=TRUE, eval=TRUE}
v1 <- c("ggplot2", 2023, TRUE)
v1
typeof(v1)
```

```{r, echo=TRUE, eval=TRUE}
v2 <- c(0.2, 1L, 3 + 0i)
v2
typeof(v2)
```

## Coercition

La règle de coercition est la suivante :

`logical ➙ integer ➙ double ➙ complex ➙ character`

```{r, echo=TRUE, eval=TRUE}
typeof(c(TRUE))
typeof(c(TRUE, 1L))
typeof(c(TRUE, 1L, 0.2))
typeof(c(TRUE, 1L, 0.2, 1 + 0i))
typeof(c(TRUE, 1L, 0.2, 1 + 0i, "a"))
```

## Coercition explicite

Il est possible de **contraindre explicitement** les valeurs d'un vecteur atomique à un type de données spécifique :

```{r, echo=TRUE, eval=TRUE}
v1
as.numeric(v1)
as.logical(v1)
```

## Coercition explicite

Il est possible de **contraindre explicitement** les valeurs d'un vecteur atomique à un type de données spécifique :

```{r, echo=TRUE, eval=TRUE}
v1
as.numeric(v1)
as.logical(v1)
```

Notez que tous les nombres à l'exception de `0` deviennent `TRUE` :

```{r, echo=TRUE, eval=TRUE}
as.logical(2023)
```

... et toutes les chaînes de caractères à l'exception de `"TRUE"`, `"FALSE"`, `"T"` et `"F"` deviennent `NA` :

```{r, echo=TRUE, eval=TRUE}
as.logical("2023")
```

## Coercition explicite

Il est possible de **contraindre explicitement** les valeurs d'un vecteur atomique à un type de données spécifique :

```{r, echo=TRUE, eval=TRUE}
v2
as.integer(v2)
as.character(v2)
as.logical(v2)
as.logical(as.character(v2))
as.logical(as.integer(v2))
```

## Mise en pratique : coercition de vecteurs

::: {.callout-tip appearance="simple" icon="false"}
-   Sans exécuter le code, essayez de prévoir le résultat des lignes suivantes :

    -   `a <- c(1.7, "1.7")` et `as.numeric(a)`

    -   `b <- c(TRUE, 2022, 1.375)` et `as.logical(as.complex(b))`

    -   `c <- c(TRUE, "t", "TRUE", "T")` et `as.logical(c)`

    -   `as.integer(c(45L, 0.237, 4.9))`
:::

::: {.callout-caution appearance="simple" icon="false"}
-   Que retourne le code as.factor(c("rouge", "bleu")) ?
:::

## Mise en pratique : coercition de vecteurs

```{r, echo=TRUE, eval=TRUE}
(a <- c(1.7, "1.7"))
as.numeric(a)
(b <- c(FALSE, 2022, 1.375))
as.logical(as.complex(b))
c <- c(TRUE, "t", "TRUE", "T")
as.logical(c)
as.integer(c(45L, 0.237, 4.9))
```

## Mise en pratique : coercition de vecteurs

```{r, echo=TRUE, eval=TRUE}
c("rouge", "bleu")
as.factor(c("rouge", "bleu"))
```

# Facteurs

## Facteurs

Les facteurs représentent des données catégorielles dans un **ordre spécifique** :

```{r, echo=TRUE, eval=TRUE}
(v <- c("bien", "neutre", "mauvais"))
as.factor(v)
factor(v)
factor(v, levels = c("bien", "neutre", "mauvais"))
factor(v, levels = rev(v))
```

## Facteurs

... même si la variable est encodée par des nombres :

```{r, echo=TRUE, eval=TRUE}
(n <- 0:3)
(f <- factor(n))
(f <- factor(n, levels = c(1:3, 0)))
mean(n)
mean(f)
```

## Niveaux et étiquettes de facteurs

`levels()` retourne les niveaux uniques dans l'ordre spécifié :

```{r, echo=TRUE, eval=TRUE}
levels(f)
```

Vous pouvez aussi préciser des étiquettes qui écrasent les valeurs d'origine :

```{r, echo=TRUE, eval=TRUE}
(ff <- factor(n, levels = c(1:3, 0), labels = c("mauvais", "neutre", "bien", "n/a")))
levels(ff)
```

## Coercition de facteurs

```{r, echo=TRUE, eval=TRUE}
ff
```

Pour transformer un facteur en nombres, utilisez `as.numeric()` :

```{r, echo=TRUE, eval=TRUE}
as.numeric(ff)
```

Notez que ceci retourne les éléments du facteur comme nombres selon les positions des niveaux !

Pour transformer à nouveau en chaînes de caractères, utilisez `as.character()` :

```{r, echo=TRUE, eval=TRUE}
as.character(ff)
```

## Coercition de facteurs : attention !

```{r, echo=TRUE, eval=TRUE}
f
```

Retourne des nombres selon les niveaux :

```{r, echo=TRUE, eval=TRUE}
as.numeric(f)
```

Retourne des nombres selon les éléments :

```{r, echo=TRUE, eval=TRUE}
as.numeric(as.character(f))
```

# Packages

## Qu'est-ce qu'un package ?

Un package est une collection de fonctions, données, et autres objets qui sont conçus pour effectuer des taches spécifiques ou résoudre certains problèmes.

Ces packages sont créés et maintenus par la communauté R, et sont souvent partagés sur le Comprehensive R Archive Network (CRAN) ou d'autres dépôts comme BioConductor.

## Installer des packages supplémentaires

Pour utiliser les fonctionnalités d'un package spécifique, vous pouvez installer le package sur votre ordinateur :

```{r, echo=TRUE, eval=FALSE}
install.packages("forcats")
## fournit des fonctions pour travailler avec des facteurs
```

```{r, echo=TRUE, eval=FALSE}
install.packages("palmerpenguins")
## contient des jeux de données utiles pour l'apprentissage
```

## Utiliser des packages : charger les librairies

Pour utiliser les fonctionnalités d'un package installé, vous devez charger le package :

```{r, echo=TRUE, eval=TRUE}
library(forcats)
```

```{r, echo=TRUE, eval=TRUE}
f <- factor(0:10)
levels(f)
fct_rev(f)
fct_relevel(f, "0", after = Inf)
```

## Utiliser des packages : charger les librairies

Pour utiliser les fonctionnalités d'un package installé, vous devez charger le package :

```{r, echo=TRUE, eval=TRUE}
library(palmerpenguins)
```

```{r, echo=TRUE, eval=TRUE}
penguins
```

## Utiliser des packages : conflits

Notez que dans certains cas, plusieurs packages peuvent contenir des fonctions (ou des jeux de données) portant le même nom.

```{r, echo=TRUE, eval=FALSE}
install.packages("dplyr")
```

```{r, echo=TRUE, eval=TRUE}
library(dplyr)
```

Si vous chargez deux fonctions portant le même nom, la fonction du package chargé en dernier sera utilisée !

## Utiliser des packages : Namespace

![](img/namespace.png){fig-align="center"}

## Utiliser des packages : Namespace

Pour éviter les conflits, il est possible de faire référence explicitement à des fonctions spécifiques à l'aide de namspaces :

```{r, echo=TRUE, eval=FALSE}
install.packages("stringr")
## fournit des fonctions pour travailler avec des chaînes de caractères
```

```{r, echo=TRUE, eval=TRUE}
stringr::str_to_sentence(c("cafe", "latte machiatto", "expresso"))
```

Les namespaces sont utiles dans les situations suivantes :

-   résoudre les conflits dans les noms de fonctions

-   utiliser des fonctions sans charger toutes les fonctionnalités d'un package

-   être explicite pour les fonctions non basiques

# Données tabulaires

## Data Frames

Vous pouvez stocker plusieurs vecteurs, avec différents types de données, comme données tabulaires dans des **data frames** :

```{r, echo=TRUE, eval=TRUE}
(df_noms <- data.frame(ids, names))
```

Vous pouvez expliciter les noms des colonnes :

```{r, echo=TRUE, eval=TRUE}
(df_noms <- data.frame(id = ids, personnage = names))
```

## Accéder aux éléments d'un Data Frame

### Lignes :

```{r, echo=TRUE, eval=TRUE}
df_noms[2, ]
```

### Colonnes :

```{r, echo=TRUE, eval=TRUE}
df_noms[, 2]
df_noms$personnage
df_noms[[2]]
```

## Accéder aux éléments d'un Data Frame

### Cellules :

```{r, echo=TRUE, eval=TRUE}
df_noms$personnages[2]
df_noms[[2]][2]
df_noms[, 2][2]
df_noms[2, 2]
```

## Accéder aux éléments d'un Data Frame

Les Data Frames supportent la correspondance partielle :

```{r, echo=TRUE, eval=TRUE}
df_noms
```

`personnage` n'est pas une colonne de `df_noms` mais ressemble à `personnages` :

```{r, echo=TRUE, eval=TRUE}
df_noms$personnage
```

## Le Data Frame moderne : le Tibble

> Les Tibbles sont une refonte moderne du data.frame, conservant ce que le temps a montré être efficace, et supprimant ce qui ne l'était pas.

```{r, echo=TRUE, eval=FALSE}
install.packages("tibble")
```

Le nom vient de la manière dont on créait ces objets à l'origine : tbl_df`()` , plus simple à prononcer "tibble diff" ou "tibble d.f.".

```{r, echo=TRUE, eval=TRUE}
(tbl_noms <- tibble::tibble(id = ids, personnages = names))
```

Comme les fonctions utilisées précédemment, `tibble()` est une fonction. Alors que `mean()` et `+` sont des fonctions de base, `tibble()` appartient à un package ajouté qui s'appelle également {tibble}.

## Data Frame vs Tibble

> Les Tibbles sont une refonte moderne du data.frame, conservant ce que le temps a montré être efficace, et supprimant ce qui ne l'était pas.

Les principales différences dans l'utilisation d'un data frame vs un tibble :

-   les tibbles possèdent une méthode d'affichage affinée

    -   seules les 10 premières lignes sont affichées, et toutes les colonnes qui rentrent sur l'écran

    -   en plus de son nom, le type de chaque colonne est affiché

    -   le type de données et les dimensions sont également affichées

## Data Frame vs Tibble

Les Tibbles possèdent une méthode d'affichage affinée :

```{r, echo=TRUE, eval=TRUE}
df_long <- data.frame(id = 1:1000 %% 10, value = runif(n = 1000, min = 0, max = 1000))
tbl_long <- tibble::tibble(id = 1:1000 %% 10, value = runif(n = 1000, min = 0, max = 1000))
```

::: columns
::: column
```{r, echo=TRUE, eval=TRUE}
df_long
```
:::

::: column
```{r, echo=TRUE, eval=TRUE}
tbl_long
```
:::
:::

## Data Frame vs Tibble

Les Tibbles possèdent une méthode d'affichage affinée :

::: columns
::: column
```{r, echo=TRUE, eval=TRUE}
as.data.frame(penguins)
```
:::

::: column
```{r, echo=TRUE, eval=TRUE}
tibble::as_tibble(penguins)
```
:::
:::

## Data Frame vs Tibble

> Les Tibbles sont une refonte moderne du data.frame, conservant ce que le temps a montré être efficace, et supprimant ce qui ne l'était pas.

Les principales différences dans l'utilisation d'un data frame vs un tibble :

-   les tibbles possèdent une méthode d'affichage affinée

    -   seules les 10 premières lignes sont affichées, et toutes les colonnes qui rentrent sur l'écran

    -   en plus de son nom, le type de chaque colonne est affiché

    -   le type de données et les dimensions sont également affichées

-   la sélection de données est plus stricte pour les tibbles

::: columns
::: column
```{r, echo=TRUE, eval=TRUE, error=TRUE}
df_long$val
```
:::

::: column
```{r, echo=TRUE, eval=TRUE, error=TRUE}
tbl_long$val
```
:::
:::

## Explorer un jeu de données

```{r, echo=TRUE, eval=FALSE}
View(tbl_long)
```

## Explorer un jeu de données

```{r, echo=TRUE, eval=FALSE}
dim(tbl_long)
str(tbl_long)
tibble::glimpse(tbl_long)
summary(tbl_long)
```

## Explorer un jeu de données

```{r, echo=TRUE, eval=FALSE}
mean(tbl_long$value)
range(tbl_long$value)
unique(tbl_long$id)
sort(unique(tbl_long$id))
length(tbl_long$id)
length(unique(tbl_long$id))
```

## Mise en pratique : travailler avec des données tabulaires

::: {.callout-tip appearance="simple" icon="false"}
-   Si ce n'est pas encore fait, installez et chargez le package {palmerpenguins}

-   Explorez le jeu de données `penguins` :

    -   nombre d'observations

    -   comptez le nombre d'observations par sexe

    -   vérifiez les années de suivi des pingouins

    -   calculez la longueur moyenne des becs (bill length)

    -   affichez les quantiles des mesures de la longueur des ailes (flipper length)

    -   stockez la colonne de masse corporelle (body mass) dans un vecteur `penguin_weights`
:::

## Mise en pratique : travailler avec des données tabulaires

```{r, echo=TRUE, eval=TRUE}
dim(penguins)  ## ou `nrow(penguins)`, `length(penguins$species)`, ...
summary(penguins$sex)
unique(penguins$year)
mean(penguins$bill_length_mm)
mean(penguins$bill_length_mm, na.rm = TRUE)
quantile(penguins$flipper_length_mm, na.rm = TRUE)
penguins_weights <- penguins$body_mass_g
```

## Listes

La liste est de loin la structure de données la plus flexible dans R. Une liste est une collection d'éléments sans aucune restriction de classe, longueur ou structure de chaque élément.

```{r, echo=TRUE, eval=TRUE}
my_list <- list(ids = 1:5, names = c("Joe", "Jack", "William", "Averell", "Rantanplan"))
my_list
```

Notez que les data frames peuvent être également considérés comme des listes tabulaires simples.

## Accéder aux éléments d'une liste

```{r, echo=TRUE, eval=TRUE}
my_list$names
my_list$names[1]
my_list[[2]]
my_list[[2]][1]
```

## Listes imbriquées

Habituellement, on entend par listes des structures de données imbriquées

```{r, echo=TRUE, eval=TRUE}
my_nested_list <- list(
  ids = list(1:5, 1),
  names = list(c("Lucky Luke", "Joe", "Jack", "William", "Averell"),
               "Rantanplan"),
  type = list(rep("humain", 5), "chien")
)
my_nested_list
```

## Listes imbriquées

```{r, echo=TRUE, eval=TRUE}
my_nested_list$names
my_nested_list$names[[1]]
my_nested_list$names[[1]][1]
my_nested_list$names[[2]][[1]][1]
```

## Listes imbriquées comme Tibbles

```{r, echo=TRUE, eval=TRUE}
my_tbl_list <- tibble::as_tibble(my_nested_list)
my_tbl_list
```

## Désimbriquer des listes imbriquées

```{r, echo=TRUE, eval=FALSE}
install.packages("tidyr")
```

```{r, echo=TRUE, eval=TRUE}
my_tbl <- tidyr::unnest(my_tbl_list)
my_tbl <- tidyr::unnest(my_tbl_list, cols = c(ids, names, type))
my_tbl
```

## Imbriquer des listes

```{r, echo=TRUE, eval=TRUE}
my_nested_tbl <- tidyr::nest(my_tbl, data = !type)
my_nested_tbl$data
```

# Créer des jeux de données

## Créer des ~~jeux de données~~ vecteurs dans R

Vous pouvez combiner des vecteurs dans un data frame ou un tibble. Les fonctions `seq()` et `rep()` sont utiles pour créer des vecteurs :

```{r, echo=TRUE, eval=TRUE}
1:10
seq(from = 0, to = 150, by = 25)
0:6*25
seq(from = 0, to = 150, length.out = 5)
rep(1:3, times = 3)
rep(1:3, each = 3)
```

## Créer des jeux de données dans R

Vous pouvez combiner des vecteurs dans un data frame ou un tibble. Les fonctions `seq()` et `rep()` sont utiles pour créer des vecteurs :

```{r, echo=TRUE, eval=TRUE}
name <- c("Rantanplan", "Idéfix", "Milou", "Bill", "Pif")
age <- seq(1, 13, by = 3)
species <- rep("chien", length(name))
id <- 1:length(name)
tibble::tibble(id, name, age, species)  ## ou `data.frame()`
```

## Créer des jeux de données dans R

Vous pouvez créer ces colonnes directement dans la fonction data.frame() ou tibble() :

```{r, echo=TRUE, eval=TRUE}
tibble::tibble(
  name = c("Rantanplan", "Idéfix", "Milou", "Bill", "Pif"),
  age = seq(1, 13, by = 3),
  species = rep("chien", length(name)),
  id = 1:length(name)
)
```

## Créer des jeux de données dans R

Vous pouvez également créer des tibbles en utilisant une disposition par ligne - un tribble :

```{r, echo=TRUE, eval=TRUE}
tibble::tribble(
  ~id, ~name,        ~age, ~species,
  1,   "Rantanplan", 1,    "chien",
  2,   "Idéfix",     4,    "chien",
  3,   "Milou",      7,    "chien",
  4,   "Bill",       10,   "chien",
  5,   "Pif",        13,   "chien"
)
```

# Importer des données

## Le workflow en data science

![Le workflow en data science, modifié à partir de "R for Data Science"](img/workflow_01.png)

## Le workflow en data science

![Le workflow en data science, modifié à partir de "R for Data Science"](img/workflow_02.png)

## Importer des données

Habituellement, vous créez des data frames en important des fichiers de données comme `.txt`, `.csv`, ...

```{r, echo=TRUE, eval=FALSE}
my_data <- read.delim("./data/cool_data.txt", sep = "\t")
my_data <- read.csv("./data/cool_data.csv")
```

Le `./` désigne un chemin relatif, à partir de votre **répertoire de travail (working directory)**.

Vous pouvez vérifier votre "wd" à l'aide de la fonction `getwd()`.

Vous pouvez aussi importer des données directement à partir d'un site internet à l'aide d'une URL valide :

```{r, echo=TRUE, eval=FALSE}
my_data <- read.csv("https:://some-webpage.com/online-data.csv")
```

## Importer des données : Tibbles

Le package {readr} fournit une méthode simple et rapide de lire des données rectangulaires stockées comme des tibbles :

```{r, echo=TRUE, eval=FALSE}
my_data <- readr::read_delim("./data/cool_data.txt", delim = "\t")
my_data <- readr::read_csv("./data/cool_data.csv")
my_data <- readr::read_csv2("./data/actually_not_a_csv_but_okay.csv")  ## `;` comme séparateur et "," comme décimale
```

## Importer des données : fichiers Excel (pas idéal)

Le package {readxl} fournit des fonctionnalités pour importer des tableaux Excel :

```{r, echo=TRUE, eval=FALSE}
my_data <- readxl::read_xls("./data/oh_no_excel_data.xls", sheet = 1)
my_data <- readxl::read_xlsx("./data/oh_no_excel_data.xlsx", sheet = 1)
```

## Importer des données : formats propres à R

Il existe également des formats propres à R comme .Rds et .Rdata / .Rda

```{r, echo=TRUE, eval=FALSE}
## R basique :
my_data <- readRDS("./data/one_of_Rs_data_formats.Rds")
```

```{r, echo=TRUE, eval=FALSE}
## package readr :
my_data <- readr::read_rds("./data/one_of_Rs_data_formats.Rds")
```

## Importer des données : trop lent ?

Le package {data.table} fournit des fonctionnalités pour importer, exporter et manipuler des données.

Les fonctions pour importer et exporter des données sont connues pour être très rapides :

```{r, echo=TRUE, eval=FALSE}
my_data <- data.table::fread("./data/cool_data.csv", sep = ",")
```
