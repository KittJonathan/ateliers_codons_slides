---
format:
  revealjs:
    theme: custom.scss
    fontsize: 1.8em
editor: visual
title-slide-attributes: 
  data-background-image: title.png
  data-background-opacity: 50%
---

![](img/title.png){fig-align="center"}

## Les ateliers codons

<br>

-   Des **créneaux réguliers** pour **découvrir** et **progresser**

-   Deux parcours : **initiation** et **perfectionnement**

-   Une **équipe d'animation**

-   Des **supports** disponibles en ligne : [ateliers-codons.netlify.app/](https://ateliers-codons.netlify.app/)

<br>

#### Sources pour cet atelier :

<br>

-   [Data visualisation - Part 1 (Our Coding Club)](https://ourcodingclub.github.io/tutorials/datavis/)

-   [Data visualisation - Part 2 (Our Coding Club)](https://ourcodingclub.github.io/tutorials/data-vis-2/)

-   R Course TU Dresden (Cédric Scherer)

## 

<br>

![Le workflow en Data Science, adapté de ["R for Data Science"](https://r4ds.hadley.nz/)](img/data_science_workflow_01.png){fig-align="center"}

## 

<br>

![Le workflow en Data Science, adapté de ["R for Data Science"](https://r4ds.hadley.nz/)](img/data_science_workflow_02.png){fig-align="center"}

## 

<br>

![Le workflow en Data Science, adapté de ["R for Data Science"](https://r4ds.hadley.nz/)](img/workflow_03.png){fig-align="center"}

## 

<br>

![Le workflow en Data Science, adapté de ["R for Data Science"](https://r4ds.hadley.nz/)](img/workflow_04.png){fig-align="center"}

# Le {tidyverse}

## 

::: columns
::: {.column width="50%"}
![Illustration de Allison Horst(https://allisonhorst.com/)](img/tidyverse_celestial.png){fig-align="left"}
:::

::: {.column width="50%"}
#### Des packages R pour la Data Science

<br>

Le `{tidyverse}` est une suite de packages R conçue pour la Data Science.

<br>

Tous les packages partagent une **philosophie**, une **syntaxe**, et des **structures de données** communes
:::
:::

## Le {tidyverse}

<br>

![](img/tidyverse_packages.png)

## Le {tidyverse}

<br>

![](img/tidyverse_packages_01.png)

# Installer et charger le {tidyverse}

## Installer le {tidyverse}

<br>

-   Installer tous les packages du `{tidyverse}` :

```{r, echo=TRUE, eval=FALSE}
install.packages("tidyverse")  
```

<br>

-   Installer uniquement les packages nécessaires :

```{r, echo=TRUE, eval=FALSE}
install.packages("readr")
install.packages("dplyr")
install.packages("tidyr")
```

## Charger le {tidyverse}

<br>

-   Charger tous les packages du `{tidyverse}` :

```{r, echo=TRUE, eval=FALSE}
library(tidyverse)
```

<br>

-   Charger uniquement les packages nécessaires :

```{r, echo=TRUE, eval=FALSE}
library(readr)
library(dplyr)
library(tidyr)
```

## Les conflits

<br>

Quand vous chargez l'ensemble du `{tidyverse}`, un message s'affiche dans la console :

```{r, echo=TRUE, eval=TRUE, message=TRUE, warning=FALSE}
library(tidyverse)
```

<br>

La section **Conflicts** vous indique que des fonctions portant le **même nom** existent dans au moins **un autre package**.

# Le jeu de données *penguins*

## Le jeu de données *penguins*

<br>

-   Données collectées et publiées par [Dr Kristen Gorman](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php) lors d'une étude menée dans la [Palmer Station](https://pallter.marine.rutgers.edu/) en Antarctique, appartenant à la [LTER](https://lternet.edu/) (Long Term Ecological Research Network).

-   Mesure de différents paramètres (par exemple la longueur des ailes, la masse corporelle) chez **342 individus** appartenant à **3 espèces** de pingouins vivant sur **3 îles** de l'archipel Palmer.

-   Deux jeux de données :

    -   données brutes (`penguins_raw`)

    -   **données nettoyées (`penguins`)**

-   Données disponibles dans un package R : [`{palmerpenguins}`](https://allisonhorst.github.io/palmerpenguins/).

## 

![](img/title_readr_read.png){fig-align="center"}

## Importer les données

<br>

#### Avec le package {readr}

-   Directement à partir de la page web :

```{r, echo=TRUE, eval=FALSE}
penguins <- read_csv("https://tinyurl.com/mr3mekye")
```

-   En important le fichier `penguins.csv` préalablement téléchargé :

```{r, echo=TRUE, eval=FALSE}
penguins <- read_csv("02-data_raw/penguins.csv")
```

<br>

#### Avec le package {palmerpenguins}

```{r, echo=TRUE, eval=FALSE}
install.packages("palmerpenguins")
penguins <- palmerpenguins::penguins
```

```{r, echo=FALSE, eval=TRUE}
penguins <- readr::read_csv("penguins.csv")
```

## 

![](img/title_dplyr_glimpse.png){fig-align="center"}

## Explorer les données

<br>

La fonction `glimpse()` permet d'afficher la structure et le contenu de données :

<br>

```{r, echo=TRUE, eval=TRUE}
glimpse(penguins)
```

## 

![](img/title_dplyr_data_wrangling.png){fig-align="center"}

## Le package {dplyr}

<br>

-   Contient un ensemble de fonctions utiles à la **transformation** et à la **synthèse** de données

<br>

-   Ces fonctions, comparées aux fonctions R basiques :

    -   ont une **syntaxe plus cohérente**

    -   ont un **nombre limité d'options**

    -   retournent toujours un **data.frame** (un ***tibble*** plus précisément)

    -   utilisent des méthodes de **stockage** de données efficaces

    -   peuvent être utilisées pour des **bases de données** et des **data tables**

## Les principaux verbes de {dplyr}

<br>

| Verbe (fonction)               | Explication                         |
|--------------------------------|-------------------------------------|
| `select()`                     | sélectionner des colonnes           |
| `filter()`                     | sélectionner des lignes             |
| `arrange()`                    | trier des données                   |
| `mutate()`                     | créer de nouvelles variables        |
| `summarise()` ou `summarize()` | synthétiser des variables           |
| `group_by()`                   | créer des sous-ensembles de données |

## La syntaxe cohérente de {dplyr}

<br>

Toutes les fonctions ont les mêmes arguments principaux :

![](img/dplyr_syntax.png)

-   Le premier argument précise **vos données**

-   Les arguments suivants indiquent **ce que vous faites de ces données**, en utilisant les **noms des variables**

## 

![](img/title_dplyr_select.png)

## Sélectionner des colonnes

<br>

```{r, echo=TRUE, eval=TRUE}
select(penguins, species, island, bill_length_mm, bill_depth_mm)
```

## Sélectionner des colonnes

<br>

```{r, echo=TRUE, eval=FALSE}
select(penguins, species, island, bill_length_mm, bill_depth_mm)
```

<br>

**En R basique :**

```{r, echo=TRUE, eval=TRUE}
penguins[, c("species", "island", "bill_length_mm", "bill_depth_mm")]
```

## Sélectionner des colonnes

<br>

Pour supprimer des colonnes, retirez-les à l'aide du **`-`** :

```{r, echo=TRUE, eval=TRUE}
select(penguins, -flipper_length_mm, -body_mass_g, -sex, -year)
```

## Sélectionner des colonnes

<br>

Conservez ou supprimez des colonnes consécutives à l'aide du **`:`** :

```{r, echo=TRUE, eval=TRUE}
select(penguins, species:bill_depth_mm)
```

## Modifier l'ordre des colonnes

<br>

Conservez ou supprimez des colonnes consécutives à l'aide du **`:`** :

```{r, echo=TRUE, eval=TRUE}
select(penguins, -(flipper_length_mm:year))
```

## Modifier l'ordre des colonnes

<br>

La fonction `select()` peut également servir à modifier l'ordre des colonnes :

```{r, echo=TRUE, eval=TRUE}
select(penguins, island, species, bill_length_mm:year)
```

## Modifier l'ordre des colonnes

<br>

La fonction `select()` peut également servir à modifier l'ordre des colonnes :

```{r, echo=TRUE, eval=TRUE}
select(penguins, island, species, everything())
```

## Modifier l'ordre des colonnes

<br>

Une autre fonction, `relocate()`, permet également de déplacer des colonnes :

```{r, echo=TRUE, eval=TRUE}
relocate(penguins, island, .before = species)
```

## Modifier l'ordre des colonnes

<br>

Une autre fonction, `relocate()`, permet également de déplacer des colonnes :

```{r, echo=TRUE, eval=TRUE}
relocate(penguins, species, .after = island)
```

## Modifier l'ordre des colonnes

<br>

Une autre fonction, `relocate()`, permet également de déplacer des colonnes :

```{r, echo=TRUE, eval=TRUE}
relocate(penguins, flipper_length_mm, .after = last_col())
```

## Renommer des colonnes

<br>

La fonction `select()` peut également servir à renommer des colonnes.

La syntaxe est la suivante :

<br>

![](img/select_rename_syntax.png)

## Renommer des colonnes

<br>

La fonction `select()` peut également servir à renommer des colonnes :

```{r, echo=TRUE, eval=TRUE}
select(penguins, island_name = island, species_name = species)
```

## Renommer des colonnes

<br>

Une autre fonction, `rename()` permet de renommer certaines colonnes et de toutes les conserver :

```{r, echo=TRUE, eval=TRUE}
rename(penguins, island_name = island, species_name = species)
```

## Mise en pratique - `select()`

<br>

Dans le jeu de données `penguins` :

-   sélectionnez les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

-   assignez cette sélection dans un objet `penguins_sel`

-   affichez l'objet `penguins_sel`

## Mise en pratique - `select()`

<br>

Dans le jeu de données `penguins` :

-   sélectionnez les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

-   assignez cette sélection dans un objet `penguins_sel`

-   affichez l'objet `penguins_sel`

```{r, echo=TRUE, eval=TRUE}
(penguins_sel <- select(penguins, species:bill_length_mm, flipper_length_mm))
```

## `starts_with()`, `ends_with()` et `contains()`

<br>

Des fonctions permettent de sélectionner des colonnes selon des motifs contenus dans les noms de colonnes :

<br>

-   `starts_with()` : sélectionner des colonnes dont le nom **commence par** un motif

-   `ends_with()` : sélectionner des colonnes dont le nom **se termine par** un motif

-   `contains()` : sélectionner des colonnes dont le nom **contient** un motif

## Mise en pratique - `select() + …()`

<br>

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `bill_depth_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, body_mass_g, `sex`, `year`

## Mise en pratique - `select() + …()`

<br>

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `bill_depth_mm`

```{r, echo=TRUE, eval=FALSE}
select(penguins, species, island, bill_length_mm, bill_depth_mm)
select(penguins, species:bill_depth_mm)
select(penguins, -(flipper_length_mm:year))
select(penguins, species, island, starts_with("bill"))
select(penguins, species, island, contains("bill"))
```

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`

<!-- -->

-   Sélectionner les colonnes `species`, `island`, body_mass_g, `sex`, `year`

## Mise en pratique - `select() + …()`

<br>

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `bill_depth_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

```{r, echo=TRUE, eval=FALSE}
select(penguins, species, island, bill_length_mm, flipper_length_mm)
select(penguins, species:bill_length_mm, flipper_length_mm)
select(penguins, -c(bill_depth_mm, body_mass_g:year))
select(penguins, species, island, ends_with("length_mm"))
select(penguins, species, island, contains("length"))
```

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, body_mass_g, `sex`, `year`

## Mise en pratique - `select() + …()`

<br>

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `bill_depth_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`

```{r, echo=TRUE, eval=FALSE}
select(penguins, species, island, bill_length_mm, bill_depth_mm, flipper_length_mm)
select(penguins, species:flipper_length_mm)
select(penguins, -(body_mass_g:year))
select(penguins, species, island, ends_with("mm"))
select(penguins, species, island, contains("mm"))
```

-   Sélectionner les colonnes `species`, `island`, body_mass_g, `sex`, `year`

## Mise en pratique - `select() + …()`

<br>

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `bill_depth_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, body_mass_g, `sex`, `year`

```{r, echo=TRUE, eval=FALSE}
select(penguins, species, island, body_mass_g, sex, year)
select(penguins, species, island, body_mass_g:year)
select(penguins, -(bill_length_mm:flipper_length_mm))
select(penguins, species, island, !ends_with("mm"))
select(penguins, species, island, !contains("mm"))
```

## 

![](img/title_dplyr_filter.png)

## Sélectionner des lignes

<br>

Utilisez les opérateurs logiques pour sélectionner des lignes :

```{r, echo=TRUE, eval=TRUE}
filter(penguins, species == "Adelie", body_mass_g >= 4700)
```

## Sélectionner des lignes

<br>

```{r, echo=TRUE, eval=FALSE}
filter(penguins, species == "Adelie", body_mass_g >= 4700)
```

<br>

**En R basique :**

```{r, echo=TRUE, eval=TRUE}
penguins[penguins$species == "Adelie" & penguins$body_mass_g >= 4700, ]
```

## Les opérateurs logiques

<br>

|        |                     |
|--------|---------------------|
| `==`   | égal à              |
| `>=`   | supérieur ou égal à |
| `<=`   | inférieur ou égal à |
| `!=`   | différent de        |
| `&`    | et                  |
| `|`    | ou                  |
| `%in%` | appartient à        |
| `!`    | pas                 |

## Mise en pratique - `filter()`

<br>

Sans assigner les données filtrées à de nouveaux objets, réalisez les opérations suivantes (il peut y avoir plusieurs possibiltés) :

-   Sélectionnez les espèces **Adelie** et **Chinstrap**

-   Sélectionnez les pingouins vivant sur l'île **Torgersen** dont la masse corporelle est **strictement supérieure à 5kg**

-   Sélectionnez les pingouins dont la **masse corporelle** est **comprise entre 4725g et 4750g**

## Mise en pratique - `filter()`

<br>

Sans assigner les données filtrées à de nouveaux objets, réalisez les opérations suivantes (plusieurs possibiltés) :

-   Sélectionnez les espèces **Adelie** et **Chinstrap**

```{r, echo=TRUE, eval=FALSE}
filter(penguins, species == "Adelie" | species == "Chinstrap")
filter(penguins, species != "Gentoo")
filter(penguins, species %in% c("Adelie", "Chinstrap"))
```

-   Sélectionnez les pingouins vivant sur l'île **Torgersen** dont la masse corporelle est **strictement supérieure à 5kg**

-   Sélectionnez les pingouins dont la **masse corporelle** est **comprise entre 4725g et 4750g**

## Mise en pratique - `filter()`

<br>

Sans assigner les données filtrées à de nouveaux objets, réalisez les opérations suivantes (plusieurs possibiltés) :

-   Sélectionnez les espèces **Adelie** et **Chinstrap**

-   Sélectionnez les pingouins vivant sur l'île **Torgersen** dont la masse corporelle est **strictement supérieure à 5kg**

```{r, echo=TRUE, eval=FALSE}
filter(penguins, island == "Torgersen", body_mass_g > 5000)
```

-   Sélectionnez les pingouins dont la **masse corporelle** est **comprise entre 4725g et 4750g**

## Mise en pratique - `filter()`

<br>

Sans assigner les données filtrées à de nouveaux objets, réalisez les opérations suivantes (il peut y avoir plusieurs possibiltés) :

-   Sélectionnez les espèces **Adelie** et **Chinstrap**

-   Sélectionnez les pingouins vivant sur l'île **Torgersen** dont la masse corporelle est **strictement supérieure à 5kg**

-   Sélectionnez les pingouins dont la **masse corporelle** est **comprise entre 4725g et 4750g**

```{r, echo=TRUE, eval=FALSE}
filter(penguins, body_mass_g >= 4725, body_mass_g <= 4750)
filter(penguins, between(body_mass_g, 4725, 4750))
```

## Données manquantes

<br>

La fonction `head()` permet d'afficher les premières lignes des données.

```{r, echo=TRUE, eval=TRUE}
head(penguins, 4)
```

<br>

Vous pouvez remarquer qu'il existe des **NA**. Il s'agit d'individus pour lesquels aucune mesure n'est disponible :

```{r, echo=TRUE, eval=TRUE}
filter(penguins, is.na(bill_length_mm))
```

## Données manquantes

<br>

Pour supprimer les lignes pour lesquelles il manque des données, vous pouvez procéder de deux façons :

-   sélectionner les lignes pour lesquelles il n'y a aucune donnée manquante :

```{r, echo=TRUE, eval=FALSE}
filter(penguins, !is.na(bill_length_mm))
```

<br>

-   utiliser la fonction `drop_na()` du package `{tidyr}`, en précisant ou non des noms de variables :

```{r, echo=TRUE, eval=FALSE}
drop_na(penguins, bill_length_mm)
drop_na(penguins)
```

## Mise en pratique - `select()` et `drop_na()`

<br>

-   Sélectionnez les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm` et assignez le tableau dans un objet `penguins_sel`

<br>

-   A partir du tableau `penguins_sel`, supprimez les données manquantes à l'aide de la fonction `drop_na()` et assignez ce nouveau tableau dans l'objet `penguins_no_na`

## Mise en pratique - `select()` et `drop_na()`

<br>

-   Sélectionnez les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm` et assignez le tableau dans un objet `penguins_sel`

```{r, echo=TRUE, eval=TRUE}
penguins_sel <- select(penguins, species:bill_length_mm, flipper_length_mm)
```

<br>

-   A partir du tableau `penguins_sel`, supprimez les données manquantes à l'aide de la fonction `drop_na()` et assignez ce nouveau tableau dans l'objet `penguins_no_na`

## Mise en pratique - `select()` et `drop_na()`

<br>

-   Sélectionnez les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm` et assignez le tableau dans un objet `penguins_sel`

```{r, echo=TRUE, eval=TRUE}
penguins_sel <- select(penguins, species:bill_length_mm, flipper_length_mm)
```

<br>

-   A partir du tableau `penguins_sel`, supprimez les données manquantes à l'aide de la fonction `drop_na()` et assignez ce nouveau tableau dans l'objet `penguins_no_na`

```{r, echo=TRUE, eval=TRUE}
penguins_no_na <- drop_na(penguins_sel)
```

## 

![](img/title_pipe.png)

## Enchaîner les opérations à l'aide du pipe `|>`

<br>

Pour enchaîner les opérations, il existe **trois approches** :

<br>

1\) Créer des objets intermédiaires

2\) Imbriquer les opérations

3\) Enchaîner les opérations à l'aide du pipe `|>`

## Enchaîner les opérations à l'aide du pipe `|>`

<br>

Pour enchaîner les opérations, il existe **trois approches** :

<br>

#### 1) Créer des objets intermédiaires

```{r, echo=TRUE, eval=FALSE}
penguins_sel <- select(penguins, species:bill_length_mm, flipper_length_mm)
penguins_no_na <- drop_na(penguins_sel)
```

2\) Imbriquer les opérations

3\) Enchaîner les opérations à l'aide du pipe `|>`

## Enchaîner les opérations à l'aide du pipe `|>`

<br>

Pour enchaîner les opérations, il existe **trois approches** :

<br>

1\) Créer des objets intermédiaires

#### 2) Imbriquer les opérations

```{r, echo=TRUE, eval=FALSE}
penguins_no_na <- drop_na(select(penguins, species:bill_length_mm, flipper_length_mm))
```

3\) Enchaîner les opérations à l'aide du pipe `|>`

## Enchaîner les opérations à l'aide du pipe `|>`

<br>

Pour enchaîner les opérations, il existe **trois approches** :

<br>

1\) Créer des objets intermédiaires

2\) Imbriquer les opérations

#### 3) Enchaîner les opérations à l'aide du pipe `|>`

```{r, echo=TRUE, eval=FALSE}
penguins |> 
  select(species:bill_length_mm, flipper_length_mm) |> 
  drop_na()
```

## Enchaîner les opérations à l'aide du pipe `|>`

<br>

L'utilisation du pipe \|\> présente plusieurs avantages :

-   **évite d'encombrer l'environnement** avec de nombreux objets intermédiaires

-   rend le **code plus lisible**

-   permet de profiter de l'**auto-complétion** (touche `Tab`)

-   permet d'enchaîner les étapes d'une analyse dans un **workflow clair** : importation, nettoyage, transformation, représentation

-   permet d'**inactiver du code** à l'aide de commentaires

```{r, echo=TRUE, eval=FALSE}
penguins |> 
# select(species:bill_length_mm, flipper_length_mm) |> 
  drop_na()
```

## `|>` versus `%>%`

<br>

Vous pourrez parfois trouver le pipe sous une autre forme : `%>%`.

Ce pipe fait partie du package `{magrittr}`, qui fait également partie du `{tidyverse}`.

<br>

Le pipe `|>` a tendance à remplacer petit à petit le pipe `%>%`, notamment parce qu'il fait partie du **R basique** (à partir de R 4.1), et ne nécessite donc pas de faire appel à un package supplémentaire.

## `|>` versus `%>%`

<br>

Il existe un **raccourci clavier** pour insérer un pipe : `Ctrl + Shift + M`.

<br>

Si vous disposez d'une version récente de R (R 4.1 +), vous pouvez paramétrer R Studio pour utiliser le pipe "natif" `|>` : *Tools \> Global Options \> Code*

![](img/rstudio_pipe.png)

## Mise en pratique - le pipe `|>`

<br>

Enchaînez les opérations suivantes à l'aide de `|>` :

-   partir du jeu de données d'origine `penguins`

-   sélectionner les colonens `species`, `island`, `bill_length_mm` et `bill_depth_mm`

-   supprimer les données manquantes

-   converser les individus ayant une longueur de bec (`bill_depth_mm`) supérieure ou égale à 55mm

## Mise en pratique - le pipe `|>`

<br>

Enchaînez les opérations suivantes à l'aide de `|>` :

-   partir du jeu de données d'origine `penguins`

-   sélectionner les colonens `species`, `island`, `bill_length_mm` et `bill_depth_mm`

-   supprimer les données manquantes

-   converser les individus ayant une longueur de bec (`bill_length_mm`) supérieure ou égale à 55mm

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  select(species:bill_depth_mm) |> 
  drop_na() |> 
  filter(bill_length_mm >= 55)
```

## 

![](img/title_dplyr_arrange.png)

## Trier les données

<br>

La fonction `arrange()` permet de trier les données par une ou plusieurs variables :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  arrange(body_mass_g)
```

## Trier les données

<br>

La fonction `arrange()` permet de trier les données par une ou plusieurs variables :

```{r, echo=TRUE, eval=FALSE}
penguins |> 
  arrange(body_mass_g)
```

<br>

**En R basique :**

```{r, echo=TRUE, eval=FALSE}
penguins[order(penguins$body_mass_g), ]
```

## Trier les données

<br>

Pour trier par **ordre décroissant**, ajoutez un `-` ou utilisez la fonction `desc()` :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  arrange(-body_mass_g)
```

<br>

```{r, echo=TRUE, eval=FALSE}
penguins |> 
  arrange(desc(body_mass_g))
```

## Trier les données

<br>

Vous pouvez trier sur plusieurs colonnes, en mélangeant les ordres croissant et décroissant :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  arrange(-body_mass_g, bill_depth_mm)
```

## Mise en pratique - `arrange()`

<br>

Sans assigner les données triées à un nouvel objet, effectuez les opérations suivantes :

-   Sélectionnez les colonnes `species`, `island`, `bill_depth_mm`

-   Sélectionner les pingouins ayant une hauteur de bec (`bill_depth_mm`) égale à 21.1mm

-   Triez les données sur la variable `island`, par ordre croissant puis décroissant. Que remarquez-vous ?

## Mise en pratique - `arrange()`

<br>

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  select(species, island, bill_depth_mm) |> 
  filter(bill_depth_mm == 21.1) |> 
  arrange(island)
penguins |> 
  select(species, island, bill_depth_mm) |> 
  filter(bill_depth_mm == 21.1) |> 
  arrange(desc(island))  ## arrange(-island) renvoie une erreur
```

<br>

**La fonction `arrange()` appliquée à une variable de type caractère trie les données par ordre alphabétique.**

## 

![](img/title_dplyr_mutate.png)

## Créer de nouvelles variables

<br>

La fonction mutate() permet de créer de nouvelles variables (colonnes) :

-   à partir de colonnes existantes

-   indépendantes de vos données

## Créer de nouvelles variables

<br>

La fonction mutate() permet de créer de nouvelles variables (colonnes) :

-   **à partir de colonnes existantes**

-   indépendantes de vos données

<br>

```{r, echo=TRUE, eval=TRUE}
penguins_sel <- penguins |> 
  select(species:bill_length_mm, body_mass_g)

penguins_sel |> 
  mutate(body_mass_kg = body_mass_g / 1000) |> 
  head(2)
```

## Créer de nouvelles variables

<br>

La fonction mutate() permet de créer de nouvelles variables (colonnes) :

-   **à partir de colonnes existantes**

-   indépendantes de vos données

<br>

**En R basique :**

```{r, echo=TRUE, eval=TRUE}
penguins_sel <- penguins |> 
  select(species:bill_length_mm, body_mass_g)

head(transform(penguins_sel, body_mass_kg = body_mass_g / 1000), 2)
```

## Créer de nouvelles variables

<br>

La fonction mutate() permet de créer de nouvelles variables (colonnes) :

-   à partir de colonnes existantes

-   **indépendantes de vos données**

<br>

```{r, echo=TRUE, eval=TRUE}
penguins_sel <- penguins |> 
  select(species:bill_length_mm, body_mass_g)

penguins_sel |> 
  mutate(note = "A verifier") |> 
  head(2)
```

## Créer de nouvelles variables

<br>

Par défaut, une colonne créée avec la fonction `mutate()` sera ajoutée **à la fin du tableau**.

Pour choisir où placer une nouvelle colonne, vous pouvez utiliser les arguments `.before` ou `.after` :

```{r, echo=TRUE, eval=TRUE}
penguins_sel <- penguins |> 
  select(species:bill_length_mm, body_mass_g)
penguins_sel |> 
  mutate(body_mass_kg = body_mass_g / 1000, .before = body_mass_g) |>
  head(2)
```

## Mise en pratique - `mutate()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   Sélectionnez les colonnes `species`, `island`, `bill_length_mm` et `bill_depth_mm`

-   Calculez le ratio longueur / hauteur de bec (`bill_length_mm` / `bill_depth_mm`) et stockez le résultat dans une nouvelle variable `bill_ratio`

-   Placez cette nouvelle colonne en troisième position

-   Affichez les 4 premières lignes

## Mise en pratique - `mutate()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   Sélectionnez les colonnes `species`, `island`, `bill_length_mm` et `bill_depth_mm`

-   Calculez le ratio longueur / hauteur de bec (`bill_length_mm` / `bill_depth_mm`) et stockez le résultat dans une nouvelle variable `bill_ratio`

-   Placez cette nouvelle colonne en troisième position

-   Affichez les 4 premières lignes

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  select(species:bill_depth_mm) |> 
  mutate(bill_ratio = bill_length_mm / bill_depth_mm, .after = island) |> 
  head(4)
```

## 

![](img/title_dplyr_summarise.png)

## Synthétiser des variables

<br>

La fonction `summarise()` permet de calculer des statistiques pour des variables données :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  summarise(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE))
```

## Synthétiser des variables

<br>

La fonction `summarise()` permet de calculer des statistiques pour des variables données :

```{r, echo=TRUE, eval=FALSE}
penguins |> 
  summarise(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE))
```

<br>

**En R basique :**

```{r, echo=TRUE, eval=TRUE}
mean(penguins$body_mass_g, na.rm = TRUE)
```

## Synthétiser des variables

<br>

La fonction `summarise()` permet de calculer des statistiques pour des variables données :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  summarise(n = n())

penguins |> 
  summarise(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),
            body_mass_g_median = median(body_mass_g, na.rm = TRUE))
```

## Mise en pratique - `summarise()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   extraire la valeur minimale de la variable `body_mass_g`

-   extraire la valeur maximale de la variable `body_mass_g`

-   extraire la valeur minimale du ratio `bill_length_mm` / `bill_depth_mm`

-   extraire la valeur maximale du ratio `bill_length_mm` / `bill_depth_mm`

## Mise en pratique - `summarise()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   extraire la valeur minimale de la variable `body_mass_g`

-   extraire la valeur maximale de la variable `body_mass_g`

-   extraire la valeur minimale du ratio `bill_length_mm` / `bill_depth_mm`

-   extraire la valeur maximale du ratio `bill_length_mm` / `bill_depth_mm`

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  summarise(body_mass_g_min = min(body_mass_g, na.rm = TRUE),
            body_mass_g_max = max(body_mass_g, na.rm = TRUE),
            bill_ratio_min = min(bill_length_mm / bill_depth_mm,
                                 na.rm = TRUE),
            bill_ratio_max = max(bill_length_mm / bill_depth_mm,
                                 na.rm = TRUE))

```

## 

![](img/title_dplyr_group_by.png)

## Créer des sous-ensembles

<br>

La fonction `group_by()` permet de séparer vos données en groupes :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  group_by(species)
```

## Créer des sous-ensembles

<br>

La fonction `group_by()` permet de séparer vos données en groupes :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  group_by(species, island)
```

## Dégrouper des données

<br>

La fonction **ungroup()** permet de dégrouper des données

```{r, echo=TRUE, eval=TRUE}
penguins_groups <- penguins |> 
  group_by(species, island)

penguins_groups |> 
  head(2)

penguins_groups |> 
  ungroup() |> 
  head(2)
```

## Appliquer des verbes à des groupes

<br>

`group_by()` utilisé avec d'autres verbes de `{dplyr}` permet de calculer des statistiques pour des groupes spécifiques sans devoir créer de nouveaux sous-ensembles :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  group_by(species, island) |> 
  summarise(body_mass_g = mean(body_mass_g, na.rm = TRUE))
```

## Appliquer des verbes à des groupes

<br>

Quand vous appliquez des verbes à des groupes créés à l'aide de `group_by()`, le `tibble` résultant conserve les groupes.

<br>

Depuis la version 1.1.0 de `{dplyr}`, l'opération de "groupage" peut se faire directement dans la fonction qu'on souhaite appliquer :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  summarise(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),
            .by = c(species, island))
```

**Le `tibble` résultant ne conserve pas la structure interne en groupes.**

## Mise en pratique - opérations sur des groupes

<br>

En partant du jeu de données `penguins` d'origine, effectuez les opérations suivantes (plusieurs possibilités) :

-   Séléctionnez les colonnes `species`, `island`, `body_mass_g`

-   Supprimez les données manquantes

-   Calculez la médiane de la masse corporelle (`body_mass_g`) par espèce et convertissez cette médiane en kg.

## Mise en pratique - opérations sur des groupes

<br>

En partant du jeu de données `penguins` d'origine, effectuez les opérations suivantes (plusieurs possibilités) :

-   Séléctionnez les colonnes `species`, `island`, `body_mass_g`

-   Supprimez les données manquantes

-   Calculez la médiane de la masse corporelle (`body_mass_g`) par espèce et convertissez cette médiane en kg.

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  select(species, island, body_mass_g) |> 
  drop_na() |> 
  mutate(body_mass_kg = body_mass_g / 1000) |> 
  group_by(species) |> 
  summarise(body_mass_kg_median = median(body_mass_kg))
```

## Mise en pratique - opérations sur des groupes

<br>

En partant du jeu de données `penguins` d'origine, effectuez les opérations suivantes (plusieurs possibilités) :

-   Séléctionnez les colonnes `species`, `island`, `body_mass_g`

-   Supprimez les données manquantes

-   Calculez la médiane de la masse corporelle (`body_mass_g`) par espèce et convertissez cette médiane en kg.

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  select(species, island, body_mass_g) |> 
  filter(!is.na(body_mass_g)) |>  
  mutate(body_mass_kg = body_mass_g / 1000) |> 
  group_by(species) |> 
  summarise(body_mass_kg_median = median(body_mass_kg))
```

## Mise en pratique - opérations sur des groupes

<br>

En partant du jeu de données `penguins` d'origine, effectuez les opérations suivantes (plusieurs possibilités) :

-   Séléctionnez les colonnes `species`, `island`, `body_mass_g`

-   Supprimez les données manquantes

-   Calculez la médiane de la masse corporelle (`body_mass_g`) par espèce et convertissez cette médiane en kg.

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  select(species, island, body_mass_g) |> 
  drop_na() |>   
  mutate(body_mass_kg = body_mass_g / 1000) |> 
  summarise(body_mass_kg_median = median(body_mass_kg),
            .by = species)
```

## Mise en pratique - opérations sur des groupes

<br>

En partant du jeu de données `penguins` d'origine, effectuez les opérations suivantes (plusieurs possibilités) :

-   Séléctionnez les colonnes `species`, `island`, `body_mass_g`

-   Supprimez les données manquantes

-   Calculez la médiane de la masse corporelle (`body_mass_g`) par espèce et convertissez cette médiane en kg.

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  select(species, island, body_mass_g) |> 
  drop_na() |>   
  summarise(body_mass_kg_median = median(body_mass_g / 1000),
            .by = species)
```

## Mise en pratique - opérations sur des groupes

<br>

En partant du jeu de données `penguins` d'origine, effectuez les opérations suivantes (plusieurs possibilités) :

-   Séléctionnez les colonnes `species`, `island`, `body_mass_g`

-   Supprimez les données manquantes

-   Calculez la médiane de la masse corporelle (`body_mass_g`) par espèce et convertissez cette médiane en kg.

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  select(species, island, body_mass_g) |> 
  summarise(body_mass_kg_median = median(body_mass_g / 1000,
                                         na.rm = TRUE),
            .by = species)
```

## Mise en pratique - opérations sur des groupes

<br>

En partant du jeu de données `penguins` d'origine, effectuez les opérations suivantes (plusieurs possibilités) :

-   Séléctionnez les colonnes `species`, `island`, `body_mass_g`

-   Supprimez les données manquantes

-   Calculez la médiane de la masse corporelle (`body_mass_g`) par espèce et convertissez cette médiane en kg.

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  summarise(body_mass_kg_median = median(body_mass_g / 1000,
                                         na.rm = TRUE),
            .by = species)
```

## Autres fonctions utiles du {tidyverse}

<br>

| Verbe (fonction)               | Explication                             |
|--------------------------------|-----------------------------------------|
| `distinct()` et `n_distinct()` | extraire et compter les valeurs uniques |
| `count()`                      | compter le nombre d'observations        |
| `slice()`                      | extraire des lignes                     |

## 

![](img/title_dplyr_distinct.png)

## Extraire les valeurs uniques

<br>

La fonction `distinct()` permet de ne garder que les valeurs uniques :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  distinct(species)
```

## Extraire les valeurs uniques

<br>

La fonction `distinct()` permet de ne garder que les valeurs uniques :

```{r, echo=TRUE, eval=FALSE}
penguins |> 
  distinct(species)
```

<br>

**En R basique :**

```{r, echo=TRUE, eval=TRUE}
unique(penguins$species)
```

## Extraire les valeurs uniques

<br>

La fonction `distinct()` permet de ne garder que les valeurs uniques :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  distinct(species, island)
```

## Extraire les valeurs uniques

<br>

Dans la fonction `distinct()`, l'argument `.keep_all = TRUE` permet de conserver toutes les colonnes :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  distinct(species, .keep_all = TRUE)
```

## Compter les valeurs uniques

<br>

La fonction `n_distinct()` permet de compter les valeurs uniques :

```{r, echo=TRUE, eval=TRUE}
n_distinct(penguins$species)
```

## Compter les valeurs uniques

<br>

La fonction `n_distinct()` permet de compter les valeurs uniques :

```{r, echo=TRUE, eval=FALSE}
n_distinct(penguins$species)
```

<br>

**En R basique :**

```{r, echo=TRUE, eval=TRUE}
length(unique(penguins$species))
```

## Mise en pratique - `distinct()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   extraire les valeurs uniques de la variable `year`

-   afficher toutes les combinaisons des variables `species`, `island` et `year`

## Mise en pratique - `distinct()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   extraire les valeurs uniques de la variable `year`

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  distinct(year)
```

-   compter le nombre de combinaisons possibles pour lees variables `species`, `island` et `year`

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  distinct(species, island, year) |> 
  n_distinct()  ## ou nrow()
```

## 

![](img/title_dplyr_slice.png)

## Extraire des lignes

<br>

La fonction `slice()` permet d'extraire des lignes en utilisant leurs positions (numéros de lignes) :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice(101:102)
```

<br>

Cette fonction peut être utilisée par groupes :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice(1, .by = species)
```

## Sélection aléatoire de lignes

<br>

La fonction `slice_sample()` permet d'extraire des lignes aléatoirement :

-   par nombre de lignes (`n = …`)

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_sample(n = 3)
```

-   par proportion de lignes (`prop = …`)

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_sample(prop = 0.01)
```

## Sélection aléatoire de lignes

<br>

La fonction `slice_sample()` peut être utilisée par groupes :

<br>

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_sample(n = 2, by = species)
```

## Extraire les valeurs maximales

<br>

La fonction `slice_max()` permet d'extraire les valeurs maximales pour une variable :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_max(order_by = flipper_length_mm, n = 3)
```

## Extraire les valeurs maximales

<br>

Par défaut, les individus ex-aequo pour la variable étudiée sont conservés.

Il peut donc arrriver qu'il y ait plus de ligne que le nombre demandé avrec l'argument `n= …`.

Pour afficher strictement le nombre de lignes demandé, vous pouvez utiliser l'argument `with_ties = FALSE` :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_max(order_by = flipper_length_mm, n = 3, with_ties = FALSE)
```

## Extraire les valeurs minimales

<br>

La fonction `slice_min()` permet d'extraire les valeurs minimales pour une variable :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_min(order_by = flipper_length_mm, n = 3)

penguins |> 
  slice_min(order_by = flipper_length_mm, prop = 0.01)
```

## Extraire les valeurs par groupes

<br>

Les fonctions `slice_max()` et `slice_min()` peuvent être appliquées à des groupes :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_max(order_by = flipper_length_mm, by = species, n = 2,
            with_ties = FALSE)
```

## Mise en pratique - `slice_*()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   sélectionnez aléatoirement 5 lignes du tableau

-   sélectionnez les 5 individus ayant la plus faible masse corporelle (`body_mass_g`)

-   sélectionnez, pour chaque année, l'individu ayant l'aile la plus longue (`flipper_length_mm`)

## Mise en pratique - `slice_*()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   sélectionnez aléatoirement 5 lignes du tableau

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_sample(n = 5)
```

-   sélectionnez les 5 individus ayant la plus faible masse corporelle (`body_mass_g`)

-   sélectionnez, pour chaque année, l'individu ayant l'aile la plus longue (`flipper_length_mm`)

## Mise en pratique - `slice_*()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   sélectionnez aléatoirement 5 lignes du tableau

-   sélectionnez les 5 individus ayant la plus faible masse corporelle (`body_mass_g`)

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_min(order_by = body_mass_g, n = 5, with_ties = FALSE)
```

-   sélectionnez, pour chaque année, l'individu ayant l'aile la plus longue (`flipper_length_mm`)

## Mise en pratique - `slice_*()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   sélectionnez aléatoirement 5 lignes du tableau

-   sélectionnez les 5 individus ayant la plus faible masse corporelle (`body_mass_g`)

-   sélectionnez, pour chaque année, l'individu ayant l'aile la plus longue (`flipper_length_mm`)

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_max(order_by = flipper_length_mm, n = 1,
            by = year, with_ties = FALSE) |> 
  select(year, species, island, flipper_length_mm)
```

## 

![](img/title_dplyr_count.png)

## Compter les observations

<br>

La fonction `count()` permet de calculer la taille de l'échantillon :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  count()
```

## Compter les observations

<br>

La fonction `count()` permet de calculer la taille de l'échantillon :

```{r, echo=TRUE, eval=FALSE}
penguins |> 
  count()
```

<br>

**En R basique :**

```{r, echo=TRUE, eval=TRUE}
nrow(penguins)
```

## Compter les observations

<br>

La fonction `count()` permet de calculer la taille de l'échantillon par groupes :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  count(species)

penguins |> 
  count(species, island)
```

## Compter les observations

<br>

L'argument `sort = TRUE` permet de trier le tableau de sortie :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  count(species, sort = TRUE)
```

## Compter les observations

<br>

La fonction `add_count()` permet d'ajouter la taille de l'échantillon au tableau d'origine en créant une nouvelle colonne :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  select(species, island) |> 
  add_count() |> 
  head(2)

penguins |> 
  select(species, island) |> 
  add_count(species, island) |> 
  head(2)
```

## Mise en pratique - `count()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   Comptez le nombre d'individus par année et triez le tableau résultant par ordre décroissant

```{=html}
<!-- -->
```
-   Comptez le nombre d'individus de l'espèce `Adelie` pour chaque île

-   Comptez le nombre d'individus par île et par espèce et renommez la nouvelle colonne `total`

## Mise en pratique - `count()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   Comptez le nombre d'individus par année et triez le tableau résultant par ordre décroissant

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  count(year, sort = TRUE)
```

-   Comptez le nombre d'individus de l'espèce `Adelie` pour chaque île

-   Comptez le nombre d'individus par île et par espèce et renommez la nouvelle colonne `total`

## Mise en pratique - `count()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   Comptez le nombre d'individus par année et triez le tableau résultant par ordre décroissant

```{=html}
<!-- -->
```
-   Comptez le nombre d'individus de l'espèce `Adelie` pour chaque île

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  filter(species == "Adelie") |> 
  count(island)
```

-   Comptez le nombre d'individus par île et par espèce et renommez la nouvelle colonne `total`

## Mise en pratique - `count()`

<br>

En partant du jeu de données d'origine `penguins`, effectuez les opérations suivantes :

-   Comptez le nombre d'individus par année et triez le tableau résultant par ordre décroissant

```{=html}
<!-- -->
```
-   Comptez le nombre d'individus de l'espèce `Adelie` pour chaque île

-   Comptez le nombre d'individus par île et par espèce et renommez la nouvelle colonne `total`

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  count(island, species, name = "total")
```

## Ressources

<br>

-   ["R for Data Science"](https://r4ds.hadley.nz/) (ouvrage de référence sur le {tidyverse})

-   [page web {tidyverse}](https://www.tidyverse.org/)

-   [aide-mémoire {readr}](https://rstudio.github.io/cheatsheets/html/data-import.html)

-   [aide-mémoire {dplyr}](https://rstudio.github.io/cheatsheets/html/data-transformation.html)

-   [aide-mémoire {tidyr}](https://rstudio.github.io/cheatsheets/html/tidyr.html)

# Merci !
