---
format:
  revealjs:
    theme: custom.scss
    fontsize: 1.8em
editor: visual
title-slide-attributes: 
  data-background-image: title.png
  data-background-opacity: 50%
---

![](img/title.png){fig-align="center"}

## 

<br>

![](img/workflow_01.png){fig-align="center"}

## 

<br>

![](img/workflow_02.png){fig-align="center"}

## 

<br>

![](img/workflow_03.png){fig-align="center"}

## 

<br>

![](img/workflow_04.png){fig-align="center"}

# Installer et charger le {tidyverse}

## Installer le {tidyverse}

<br>

-   Installer tous les packages du {tidyverse} :

```{r, echo=TRUE, eval=FALSE}
install.packages("tidyverse")  
```

<br>

-   Installer uniquement les packages nécessaires :

```{r, echo=TRUE, eval=FALSE}
install.packages("readr")
install.packages("dplyr")
install.packages("tidyr")
```

## Charger le {tidyverse}

<br>

-   Charger tous les packages du {tidyverse}

```{r, echo=TRUE, eval=FALSE}
library(tidyverse)
```

<br>

-   Charger uniquement les packages nécessaires

```{r, echo=TRUE, eval=FALSE}
library(readr)
library(dplyr)
library(tidyr)
```

## Les conflits

<br>

Quand vous chargez l'ensemble du {tidyverse}, un message s'affiche dans la console :

```{r, echo=TRUE, eval=TRUE, message=TRUE, warning=FALSE}
library(tidyverse)
```

<br>

La section **Conflicts** vous indique que des fonctions portant le **même nom** existent dans au moins **un autre package**.

# Le jeu de données *penguins*

## Le jeu de données *penguins*

<br>

-   Données collectées et publiées par [Dr Kristen Gorman](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php) lors d'une étude menée dans la [Palmer Station](https://pallter.marine.rutgers.edu/) en Antarctique, appartenant à la [LTER](https://lternet.edu/) (Long Term Ecological Research Network).

-   Mesure de différents paramètres (par exemple la longueur des ailes, la masse corporelle) chez **342 individus** appartenant à **trois espèces** de pingouins vivant sur **trois îles** de l'archipel Palmer.

-   Deux jeux de données :

    -   données brutes (`penguins_raw`)

    -   **données nettoyées (`penguins`)**

-   Données disponibles dans un package R : [`{palmerpenguins}`](https://allisonhorst.github.io/palmerpenguins/).

## 

![](img/title_readr_read.png){fig-align="center"}

## Importer les données

<br>

#### Avec le package {readr}

-   Directement à partir de la page web :

```{r, echo=TRUE, eval=FALSE}
url <- "https://raw.githubusercontent.com/allisonhorst/palmerpenguins/main/inst/extdata/penguins.csv"
penguins <- read_csv(url)
```

-   En important le fichier `penguins.csv` préalablement téléchargé :

```{r, echo=TRUE, eval=FALSE}
penguins <- read_csv("02-data_raw/penguins.csv")
```

<br>

#### Avec le package {palmerpenguins}

```{r, echo=TRUE, eval=FALSE}
install.packages("palmerpenguins")
penguins <- palmerpenguins::penguins
```

```{r, echo=FALSE, eval=TRUE}
penguins <- readr::read_csv("penguins.csv")
```

## 

![](img/title_dplyr_glimpse.png){fig-align="center"}

## Explorer les données

<br>

La fonction `glimpse()` permet d'afficher la structure et le contenu de données :

<br>

```{r, echo=TRUE, eval=TRUE}
glimpse(penguins)
```

## 

![](img/title_dplyr_data_wrangling.png){fig-align="center"}

## Le package {dplyr}

<br>

-   Contient un ensemble de fonctions utiles à la **transformation** et à la **synthèse** de données

<br>

-   Ces fonctions, comparées aux fonctions R basiques :

    -   ont une syntaxe plus cohérente

    -   ont un nombre limité d'options

    -   retournent toujours un data.frame (un tibble plus précisément)

    -   utilisent des méthodes de stockage de données efficaces

    -   peuvent être utilisées pour des bases de données et des data tables

## Les principaux verbes de {dplyr}

<br>

| Verbe (fonction)               | Explication                         |
|--------------------------------|-------------------------------------|
| `select()`                     | sélectionner des colonnes           |
| `filter()`                     | sélectionner des lignes             |
| `arrange()`                    | trier des données                   |
| `mutate()`                     | créer de nouvelles variables        |
| `summarise()` ou `summarize()` | synthétiser des variables           |
| `group_by()`                   | créer des sous-ensembles de données |

## La syntaxe cohérente de {dplyr}

<br>

Toutes les fonctions ont les mêmes arguments principaux :

![](img/dplyr_syntax.png)

-   Le premier argument précise **vos données**

-   Les arguments suivants indiquent **ce que vous faites de ces données**, en utilisant les **noms des variables**

## 

![](img/title_dplyr_select.png)

## Sélectionner des colonnes

<br>

```{r, echo=TRUE, eval=TRUE}
select(penguins, species, island, bill_length_mm, bill_depth_mm)
```

## Sélectionner des colonnes

<br>

```{r, echo=TRUE, eval=FALSE}
select(penguins, species, island, bill_length_mm, bill_depth_mm)
```

<br>

**En R basique :**

```{r, echo=TRUE, eval=TRUE}
penguins[, c("species", "island", "bill_length_mm", "bill_depth_mm")]
```

## Sélectionner des colonnes

<br>

Pour supprimer des colonnes, retirez-les à l'aide du **`-`**

```{r, echo=TRUE, eval=TRUE}
select(penguins, -flipper_length_mm, -body_mass_g, -sex, -year)
```

## Sélectionner des colonnes

<br>

Conservez ou supprimez des colonnes consécutives à l'aide du **`:`** :

```{r, echo=TRUE, eval=TRUE}
select(penguins, species:bill_depth_mm)
```

## Sélectionner des colonnes

<br>

Conservez ou supprimez des colonnes consécutives à l'aide du **`:`** :

```{r, echo=TRUE, eval=TRUE}
select(penguins, -(flipper_length_mm:year))
```

## Sélectionner des colonnes

<br>

La fonction select() peut également servir à modifier l'ordre des colonnes :

```{r, echo=TRUE, eval=TRUE}
select(penguins, island, species, bill_length_mm:year)
```

## Sélectionner des colonnes

<br>

La fonction select() peut également servir à modifier l'ordre des colonnes :

```{r, echo=TRUE, eval=TRUE}
select(penguins, island, species, everything())
```

## Mise en pratique - `select()`

<br>

Dans le jeu de données `penguins` :

-   sélectionnez les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

-   assignez cette sélection dans un objet `penguins_sel`

-   affichez l'objet `penguins_sel`

## Mise en pratique - `select()`

<br>

Dans le jeu de données `penguins` :

-   sélectionnez les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

-   assignez cette sélection dans un objet `penguins_sel`

-   affichez l'objet `penguins_sel`

```{r, echo=TRUE, eval=TRUE}
(penguins_sel <- select(penguins, species:bill_length_mm, flipper_length_mm))
```

## `starts_with()`, `ends_with()` et `contains()`

<br>

Des fonctions permettent de sélectionner des colonnes selon des motifs contenus dans les noms de colonnes :

<br>

-   `starts_with()` : sélectionner des colonnes dont le nom **commence par** un motif

-   `ends_with()` : sélectionner des colonnes dont le nom **se termine par** un motif

-   `contains()` : sélectionner des colonnes dont le nom **contient** un motif

## Mise en pratique - `select() + …()`

<br>

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `bill_depth_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, body_mass_g, `sex`, `year`

## Mise en pratique - `select() + …()`

<br>

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `bill_depth_mm`

```{r, echo=TRUE, eval=FALSE}
select(penguins, species, island, bill_length_mm, bill_depth_mm)
select(penguins, species:bill_depth_mm)
select(penguins, -(flipper_length_mm:year))
select(penguins, species, island, starts_with("bill"))
select(penguins, species, island, contains("bill"))
```

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`

<!-- -->

-   Sélectionner les colonnes `species`, `island`, body_mass_g, `sex`, `year`

## Mise en pratique - `select() + …()`

<br>

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `bill_depth_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

```{r, echo=TRUE, eval=FALSE}
select(penguins, species, island, bill_length_mm, flipper_length_mm)
select(penguins, species:bill_length_mm, flipper_length_mm)
select(penguins, -c(bill_depth_mm, body_mass_g:year))
select(penguins, species, island, ends_with("length_mm"))
select(penguins, species, island, contains("length"))
```

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, body_mass_g, `sex`, `year`

## Mise en pratique - `select() + …()`

<br>

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `bill_depth_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`

```{r, echo=TRUE, eval=FALSE}
select(penguins, species, island, bill_length_mm, bill_depth_mm, flipper_length_mm)
select(penguins, species:flipper_length_mm)
select(penguins, -(body_mass_g:year))
select(penguins, species, island, ends_with("mm"))
select(penguins, species, island, contains("mm"))
```

-   Sélectionner les colonnes `species`, `island`, body_mass_g, `sex`, `year`

## Mise en pratique - `select() + …()`

<br>

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `bill_depth_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`

-   Sélectionner les colonnes `species`, `island`, body_mass_g, `sex`, `year`

```{r, echo=TRUE, eval=FALSE}
select(penguins, species, island, body_mass_g, sex, year)
select(penguins, species, island, body_mass_g:year)
select(penguins, -(bill_length_mm:flipper_length_mm))
select(penguins, species, island, !ends_with("mm"))
select(penguins, species, island, !contains("mm"))
```

## 

![](img/title_dplyr_filter.png)

## Sélectionner des lignes

<br>

Utilisez les opérateurs logiques pour sélectionner des lignes :

```{r, echo=TRUE, eval=TRUE}
filter(penguins, species == "Adelie", body_mass_g >= 4700)
```

## Sélectionner des lignes

<br>

```{r, echo=TRUE, eval=FALSE}
filter(penguins, species == "Adelie", body_mass_g >= 4700)
```

<br>

**En R basique :**

```{r, echo=TRUE, eval=TRUE}
penguins[penguins$species == "Adelie" & penguins$body_mass_g >= 4700, ]
```

## Les opérateurs logiques

<br>

|        |                     |
|--------|---------------------|
| `==`   | égal à              |
| `>=`   | supérieur ou égal à |
| `<=`   | inférieur ou égal à |
| `!=`   | différent de        |
| `&`    | et                  |
| `|`    | ou                  |
| `%in%` | appartient à        |
| `!`    | pas                 |

## Mise en pratique - `filter()`

<br>

Sans assigner les données filtrées à de nouveaux objets, réalisez les opérations suivantes (plusieurs possibiltés) :

-   Sélectionnez les espèces **Adelie** et **Chinstrap**

-   Sélectionnez les pingouins vivant sur l'île **Torgersen** dont la masse corporelle est **strictement supérieure à 5kg**

-   Sélectionnez les pingouins dont la **masse corporelle** est **comprise entre 4725g et 4750g**

## Mise en pratique - `filter()`

<br>

Sans assigner les données filtrées à de nouveaux objets, réalisez les opérations suivantes (plusieurs possibiltés) :

-   Sélectionnez les espèces **Adelie** et **Chinstrap**

```{r, echo=TRUE, eval=FALSE}
filter(penguins, species == "Adelie" | species == "Chinstrap")
filter(penguins, species != "Gentoo")
filter(penguins, species %in% c("Adelie", "Chinstrap"))
```

-   Sélectionnez les pingouins vivant sur l'île **Torgersen** dont la masse corporelle est **strictement supérieure à 5kg**

-   Sélectionnez les pingouins dont la **masse corporelle** est **comprise entre 4725g et 4750g**

## Mise en pratique - `filter()`

<br>

Sans assigner les données filtrées à de nouveaux objets, réalisez les opérations suivantes (plusieurs possibiltés) :

-   Sélectionnez les espèces **Adelie** et **Chinstrap**

-   Sélectionnez les pingouins vivant sur l'île **Torgersen** dont la masse corporelle est **strictement supérieure à 5kg**

```{r, echo=TRUE, eval=FALSE}
filter(penguins, island == "Torgersen", body_mass_g > 5000)
```

-   Sélectionnez les pingouins dont la **masse corporelle** est **comprise entre 4725g et 4750g**

## Mise en pratique - `filter()`

<br>

Sans assigner les données filtrées à de nouveaux objets, réalisez les opérations suivantes (il peut y avoir plusieurs possibiltés) :

-   Sélectionnez les espèces **Adelie** et **Chinstrap**

-   Sélectionnez les pingouins vivant sur l'île **Torgersen** dont la masse corporelle est **strictement supérieure à 5kg**

-   Sélectionnez les pingouins dont la **masse corporelle** est **comprise entre 4725g et 4750g**

```{r, echo=TRUE, eval=FALSE}
filter(penguins, body_mass_g >= 4725, body_mass_g <= 4750)
filter(penguins, between(body_mass_g, 4725, 4750))
```

## Données manquantes

<br>

La fonction `head()` permet d'afficher les premières lignes des données.

```{r, echo=TRUE, eval=TRUE}
head(penguins, 4)
```

<br>

Vous pouvez remarquer qu'il existe des **NA**. Il s'agit d'individus pour lesquels aucune mersure du bec ou des ailes n'est disponible :

```{r, echo=TRUE, eval=TRUE}
filter(penguins, is.na(bill_length_mm))
```

## Données manquantes

<br>

Pour supprimer les lignes pour lesquelles il manque des données, vous pouvez procéder de deux façons :

-   sélectionner les lignes pour lesquelles il n'y a aucune donnée manquante :

```{r, echo=TRUE, eval=FALSE}
filter(penguins, !is.na(bill_length_mm))
```

<br>

-   utiliser la fonction `drop_na()` du package `{tidyr}`, en précisant ou non des noms de variables :

```{r, echo=TRUE, eval=FALSE}
drop_na(penguins, bill_length_mm)
drop_na(penguins)
```

## Mise en pratique - `select()` et `drop_na()`

<br>

-   Sélectionnez les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm` et assignez le tableau dans un objet `penguins_sel`

<br>

-   A partir du tableau `penguins_sel`, supprimez les données manquantes à l'aide de la fonction `drop_na()` et assignez ce nouveau tableau dans l'objet `penguins_no_na`

## Mise en pratique - `select()` et `drop_na()`

<br>

-   Sélectionnez les colonnes `species`, `island`, `bill_length_mm`, `flipper_length_mm` et `body_mass_g` et assignez le tableau dans un objet `penguins_sel`

```{r, echo=TRUE, eval=TRUE}
penguins_sel <- select(penguins, species:bill_length_mm, flipper_length_mm, body_mass_g)
```

<br>

-   A partir du tableau `penguins_sel`, supprimez les données manquantes à l'aide de la fonction `drop_na()` et assignez ce nouveau tableau dans l'objet `penguins_no_na`

## Mise en pratique - `select()` et `drop_na()`

<br>

-   Sélectionnez les colonnes `species`, `island`, `bill_length_mm` et `flipper_length_mm` et assignez le tableau dans un objet `penguins_sel`

```{r, echo=TRUE, eval=TRUE}
penguins_sel <- select(penguins, species:bill_length_mm, flipper_length_mm, body_mass_g)
```

<br>

-   A partir du tableau `penguins_sel`, supprimez les données manquantes à l'aide de la fonction `drop_na()` et assignez ce nouveau tableau dans l'objet `penguins_no_na`

```{r, echo=TRUE, eval=TRUE}
penguins_no_na <- drop_na(penguins_sel)
```

## 

![](img/title_pipe.png)

## Enchaîner les opérations à l'aide du pipe `|>`

<br>

Pour enchaîner les opérations, il existe **trois approches** :

<br>

1\) Créer des objets intermédiaires

2\) Imbriquer les opérations

3\) Enchaîner les opérations à l'aide du pipe `|>`

## Enchaîner les opérations à l'aide du pipe `|>`

<br>

Pour enchaîner les opérations, il existe **trois approches** :

<br>

#### 1) Créer des objets intermédiaires

```{r, echo=TRUE, eval=FALSE}
penguins_sel <- select(penguins, species:bill_length_mm, flipper_length_mm, body_mass_g)
penguins_no_na <- drop_na(penguins_sel)
```

2\) Imbriquer les opérations

3\) Enchaîner les opérations à l'aide du pipe `|>`

## Enchaîner les opérations à l'aide du pipe `|>`

<br>

Pour enchaîner les opérations, il existe **trois approches** :

<br>

1\) Créer des objets intermédiaires

#### 2) Imbriquer les opérations

```{r, echo=TRUE, eval=FALSE}
penguins_no_na <- drop_na(select(penguins, species:bill_length_mm, flipper_length_mm, body_mass_g))
```

3\) Enchaîner les opérations à l'aide du pipe `|>`

## Enchaîner les opérations à l'aide du pipe `|>`

<br>

Pour enchaîner les opérations, il existe **trois approches** :

<br>

1\) Créer des objets intermédiaires

2\) Imbriquer les opérations

#### 3) Enchaîner les opérations à l'aide du pipe `|>`

```{r, echo=TRUE, eval=FALSE}
penguins |> 
  select(species:bill_length_mm, flipper_length_mm, body_mass_g) |> 
  drop_na()
```

## Enchaîner les opérations à l'aide du pipe `|>`

<br>

L'utilisation du pipe \|\> présente plusieurs avantages :

-   **évite d'encombrer l'environnement** avec de nombreux objets intermédiaires

-   rend le **code plus lisible**

-   permet de profiter de l'**auto-complétion** (touche `Tab`)

-   permet d'enchaîner les étapes d'une analyse dans un **workflow clair** : importation, nettoyage, transformation, représentation

-   permet d'**inactiver du code** à l'aide de commentaires

```{r, echo=TRUE, eval=FALSE}
penguins |> 
# select(species:bill_length_mm, flipper_length_mm, body_mass_g) |> 
  drop_na()
```

## `|>` versus `%>%`

<br>

Vous pourrez parfois trouver le pipe sous une autre forme : `%>%`.

Ce pipe fait partie du package `{magrittr}`, qui fait également partie du `{tidyverse}`.

<br>

Le pipe `|>` a tendance à remplacer petit à petit le pipe %\>%, notamment parce qu'il fait partie du **R basique** (à partir de R 4.1), et ne nécessite donc pas de faire appel à un package supplémentaire.

## `|>` versus `%>%`

<br>

Il existe un **raccourci clavier** pour insérer un pipe : `Ctrl + Shift + M`.

<br>

Si vous disposez d'une version récente de R (R 4.1 +), vous pouvez paramétrer R Studio pour utiliser le pipe "natif" `|>` : *Tools \> Global Options \> Code*

![](img/rstudio_pipe.png)

## 

![](img/title_dplyr_arrange.png)

## Trier les données

<br>

La fonction arrange() permet de trier les données par variables :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  arrange(body_mass_g)
```

<br>

**En R basique :**

```{r, echo=TRUE, eval=FALSE}
penguins[order(penguins$body_mass_g), ]
```

## Trier les données

<br>

Pour trier par ordre décroissant, ajoutez un `-` ou utilisez la fonction `desc()` :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  arrange(-body_mass_g)
```

```{r, echo=TRUE, eval=FALSE}
penguins |> 
  arrange(desc(body_mass_g))
```

## Trier les données

<br>

Vous pouvez trier sur plusieurs colonnes :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  arrange(-body_mass_g, bill_depth_mm)
```

## Mise en pratique - `arrange()`

<br>

Sans assigner les données triées à un nouvel objet, effectuez les opérations suivantes :

-   Sélectionnez les colonnes species, island, bill_depth_mm

-   Sélectionner les pingouins ayant une hauteur de bec (bill_depth_mm) égale à 21.1mm

-   Triez les données sur la variable island, par ordre croissant puis décroissant. Que remarquez-vous ?

## Mise en pratique - `arrange()`

<br>

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  select(species, island, bill_depth_mm) |> 
  filter(bill_depth_mm == 21.1) |> 
  arrange(island)
penguins |> 
  select(species, island, bill_depth_mm) |> 
  filter(bill_depth_mm == 21.1) |> 
  arrange(desc(island))  ## arrange(-island) renvoie une erreur
```

<br>

**La fonction `arrange()` appliquée à une variable de type caractère trie les données par ordre alphabétique.**

## 

![](img/title_dplyr_mutate.png)

## Créer de nouvelles variables

<br>

La fonction mutate() permet de créer de nouvelles variables (colonnes) :

-   à partir de colonnes existantes

-   indépendantes de vos données

## Créer de nouvelles variables

<br>

La fonction mutate() permet de créer de nouvelles variables (colonnes) :

-   **à partir de colonnes existantes**

-   indépendantes de vos données

<br>

```{r, echo=TRUE, eval=TRUE}
penguins_sel <- penguins |> 
  select(species:bill_length_mm, body_mass_g)

penguins_sel |> 
  mutate(body_mass_kg = body_mass_g / 1000) |> 
  head(2)
```

## Créer de nouvelles variables

<br>

La fonction mutate() permet de créer de nouvelles variables (colonnes) :

-   **à partir de colonnes existantes**

-   indépendantes de vos données

<br>

**En R basique :**

```{r, echo=TRUE, eval=TRUE}
penguins_sel <- penguins |> 
  select(species:bill_length_mm, body_mass_g)

head(transform(penguins_sel, body_mass_kg = body_mass_g / 1000), 2)
```

## Créer de nouvelles variables

<br>

La fonction mutate() permet de créer de nouvelles variables (colonnes) :

-   à partir de colonnes existantes

-   **indépendantes de vos données**

<br>

```{r, echo=TRUE, eval=TRUE}
penguins_sel <- penguins |> 
  select(species:bill_length_mm, body_mass_g)

penguins_sel |> 
  mutate(note = "A verifier") |> 
  head(2)
```

## 

![](img/title_dplyr_summarise.png)

## Synthétiser des variables

<br>

La fonction `summarise()` vous permet de calculer des statistiques pour des variables données :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  summarise(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE))
```

<br>

**En R basique :**

```{r, echo=TRUE, eval=TRUE}
mean(penguins$body_mass_g, na.rm = TRUE)
```

## Synthétiser des variables

<br>

La fonction `summarise()` vous permet de calculer des statistiques pour des variables données :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  summarise(n = n())

penguins |> 
  summarise(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),
            body_mass_g_median = median(body_mass_g, na.rm = TRUE))
```

## 

![](img/title_dplyr_group_by.png)

## Créer des sous-ensembles

<br>

La fonction `group_by()` vous permet de séparer vos données en groupes :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  group_by(species)
```

## Créer des sous-ensembles

<br>

La fonction `group_by()` vous permet de séparer vos données en groupes :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  group_by(species, island)
```

## Dégrouper des données

<br>

La fonction **ungroup()** permet de dégrouper des données

```{r, echo=TRUE, eval=TRUE}
penguins_groups <- penguins |> 
  group_by(species, island)

penguins_groups |> 
  head(2)

penguins_groups |> 
  ungroup() |> 
  head(2)
```

## Appliquer des verbes à des groupes

<br>

`group_by()` utilisé avec d'autres verbes de `{dplyr}` permet de calculer des statistiques pour des groupes spécifiques sans devoir créer de nouveaux sous-ensembles :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  group_by(species, island) |> 
  summarise(body_mass_g = mean(body_mass_g, na.rm = TRUE))
```

## Autres fonctions utiles du {tidyverse}

<br>

| Verbe (fonction)               | Explication                             |
|--------------------------------|-----------------------------------------|
| `distinct()` et `n_distinct()` | extraire et compter les valeurs uniques |
| `count()`                      | compter le nombre d'observations        |
| `slice()`                      | extraire des lignes                     |

## 

![](img/title_dplyr_distinct.png)

## Extraire les valeurs uniques

<br>

La fonction distinct() permet de ne garder que les valeurs uniques :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  distinct(species)
```

<br>

En R basique :

```{r, echo=TRUE, eval=TRUE}
unique(penguins$species)
```

## Extraire les valeurs uniques

<br>

La fonction distinct() permet de ne garder que les valeurs uniques :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  distinct(species, island)
```

## Compter les valeurs uniques

<br>

La fonction n_distinct() permet de compter les valeurs uniques :

```{r, echo=TRUE, eval=TRUE}
n_distinct(penguins$species)
```

<br>

En R basique :

```{r, echo=TRUE, eval=TRUE}
length(unique(penguins$species))
```

## 

![](img/title_dplyr_slice.png)

## Extraire des lignes

<br>

La fonction slice() permet d'extraire des lignes en utilisant leurs emplacements :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice(101:102)
```

<br>

Cette fonction peut être utilisée par groupes :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  group_by(species) |> 
  slice(1)
```

## Sélection aléatoire de lignes

<br>

La fonction slice_sample() permet d'extraire des lignes aléatoirement :

-   par nombre de lignes (n = ...)

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_sample(n = 3)
```

-   par proportion de lignes (prop = ...)

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_sample(prop = 0.01)
```

## Sélection aléatoire de lignes

<br>

La fonction slice_sample() peut être utilisée par groupes :

<br>

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  group_by(species) |> 
  slice_sample(n = 2)
```

## Extraire les valeurs maximales

<br>

La fonction slice_max() permet d'extraire les valeurs maximales, pour une variable :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_max(order_by = body_mass_g, n = 3)
```

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_max(order_by = body_mass_g, n = 3, with_ties = FALSE)
```

## Extraire les valeurs minimales

<br>

La fonction slice_min() permet d'extraire les valeurs minimales, pour une variable :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  slice_min(order_by = flipper_length_mm, n = 3)

penguins |> 
  slice_min(order_by = flipper_length_mm, prop = 0.01)
```

## 

![](img/title_dplyr_count.png)

## Compter les observations

<br>

La fonction count() permet de calculer la taille de l'échantillon :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  count()
```

<br>

En R basique :

```{r, echo=TRUE, eval=TRUE}
nrow(penguins)
```

## Compter les observations

<br>

La fonction count() permet de calculer la taille de l'échantillon par groupes :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  count(species)

penguins |> 
  count(species, island)
```

## Compter les observations

<br>

L'argument sort = TRUE permet de trier le tableau de sortie :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  count(species, sort = TRUE)
```

## Compter les observations

<br>

La fonction add_count() permet d'ajouter la taille de l'échantillon au tableau d'origine en créant une nouvelle colonne :

```{r, echo=TRUE, eval=TRUE}
penguins |> 
  select(species, island) |> 
  add_count() |> 
  head(2)

penguins |> 
  select(species, island) |> 
  add_count(species, island) |> 
  head(2)
```
